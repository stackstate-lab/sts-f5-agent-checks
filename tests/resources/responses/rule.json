{
  "kind": "tm:ltm:rule:rulecollectionstate",
  "selfLink": "https://localhost/mgmt/tm/ltm/rule?ver=16.1.3",
  "items": [
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "ProxyPass_v10_9_orig",
      "partition": "Common",
      "fullPath": "/Common/ProxyPass_v10_9_orig",
      "generation": 625,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~ProxyPass_v10_9_orig?ver=16.1.3",
      "apiAnonymous": "# ProxyPass iRule, Version 10.9\n# Nov 26 2012\n# THIS VERSION REQUIRES TMOS v10 or higher. Use ProxyPass v8.2 for TMOS 9.x.\n\n# This version does not work with APM-enabled virtual servers, please\n# download ProxyPass 10.2APM for this use case.\n\n# Created by Kirk Bauer\n# https://devcentral.f5.com/wiki/default.aspx/iRules/ProxyPassV10.html\n# (please see end of iRule for additional credits)\n\n# Purpose:\n# iRule to replace the functionality of Apache Webserver ProxyPass and\n# ProxyPassReverse functions.  It allows you to perform host name and path name\n# modifications as HTTP traffic passes through the LTM.  In other words, you\n# can have different hostnames and directory names on the client side as you\n# do on the server side and ProxyPass handles the necessary translations.\n\n# NOTE: You should not need to modify this iRule in any way except the settings\n# in the RULE_INIT event.  Just apply the iRule to the virtual server and\n# define the appropriate Data Group and you are done.  If you do make any\n# changes to this iRule, please send your changes and reasons to me so that\n# I may understand how ProxyPass is being used and possibly incorporate your\n# changes into the core release. \n\n# Configuration Requirements\n# 1) The ProxyPass iRule needs to be applied to an HTTP virtual server or\n# an HTTPS virtual server with a clientssl profile applied to it.\n# 2) A data group (LTM -> iRules -> Data Groups tab) must be defined with\n# the name \"ProxyPassVIRTUAL\" where VIRTUAL is the name of the virtual server\n# (case-sensitive!).  See below for the format of this data group (class).\n# For 10.0.x, you must use an EXTERNAL data group.\n# 3) You must define a default pool on the virtual server unless you specify\n# a pool in every entry in the data group.  \n# 4) If you are using ProxyPass to select alternate pools, you must define\n# a OneConnect profile in most cases!\n# 5) ProxyPass does not rewrite links embedded within pages by default, just \n# headers.  If you want to change this, edit the $static::RewriteResponsePayload variable in RULE_INIT\n# and apply the default stream profile to the virtual server.\n\n# Data Group Information\n# For 10.0.x, you must define an external data group (type=String, read-only) which loads \n# from a file on your BIG-IP.  For 10.1 and higher you can use an internal string data group with name=value pairings.\n# The format of the file is as follows:\n#    \"clientside\" := \"serverside\",\n# or\n#    \"clientside\" := \"serverside poolname\",\n# The clientside and serverside fields must contain a URI (at least a \"/\") and\n# may also contain a hostname.  Here are some examples:\n#    \"/clientdir\" := \"/serverdir\",\n#    \"www.host.com/clientdir\" := \"internal.company.com/serverdir\",\n#    \"www.host.com/\" := \"internal.company.com/serverdir/\",\n\n# Notes:\n# 1) You can optionally define a ProxyPassSNATs data group to SNAT based\n# on the pool selected.\n# 2) You can optionally define a ProxyPassSSLProfiles data group to select\n# a serverssl profile based on the pool selected.\n# 3) You can also use regular expressions which is documented on DevCentral.\n\nwhen RULE_INIT {\n\t# Enable to debug ProxyPass translations via log messages in /var/log/ltm\n\t# (2 = verbose, 1 = essential, 0 = none)\n\tset static::ProxyPassDebug 0\n\n\t# Enable to rewrite page content (try a setting of 1 first)\n\t# (2 = attempt to rewrite host/path and just /path, 1 = attempt to rewrite host/path)\n\tset static::RewriteResponsePayload 0\n}\n\nwhen CLIENT_ACCEPTED {\n\t# Get the default pool name.  This is used later to explicitly select \n\t# the default pool for requests which don't have a pool specified in \n\t# the class.\n\tset default_pool [LB::server pool]\n\n\t# The name of the Data Group (aka class) we are going to use. \n\t# Parse just the virtual server name by stripping off the folders (if present)\n\tset clname \"ProxyPass[URI::basename [virtual name]]\"\n\n\tif { $static::ProxyPassDebug > 1 } {\n#\t\tlog local0. \"[virtual name]: [IP::client_addr]:[TCP::client_port] -> [IP::local_addr]:[TCP::local_port]\"\n\t}\n}\n\nwhen HTTP_REQUEST {\n\t# \"bypass\" tracks whether or not we made any changes inbound so we\n\t# can skip changes on the outbound traffic for greater efficiency.\n\tset bypass 1\n\n\t# Initialize other local variables used in this rule\n\tset orig_uri \"[HTTP::uri]\"\n\tset orig_host \"[HTTP::host]\"\n\tset log_prefix \"VS=[virtual name], Host=$orig_host, URI=$orig_uri\"\n\tset clientside \"\"\n\tset serverside \"\"\n\tset newpool \"\"\n\tset ppass \"\"\n\n\tif {! [class exists $clname]} {\n#\t\tlog local0. \"$log_prefix: Data group $clname not found, exiting.\"\n\t\tpool $default_pool\n\t\treturn\n\t} else {\n\t\tset ppass [class match -element \"$orig_host$orig_uri\" starts_with $clname]\n\t\tif {$ppass eq \"\"} {\n\t\t\t# Did not find with hostname, look for just path\n\t\t\tset ppass [class match -element \"$orig_uri\" starts_with $clname]\n\t\t}\n\t\tif {$ppass eq \"\"} {\n\t\t\t# No entries found\n\t\t\tif { $static::ProxyPassDebug > 0 } {\n#\t\t\t\tlog local0. \"$log_prefix: No rule found, using default pool $default_pool and exiting\"  \n\t\t\t}\n\t\t\tpool $default_pool\n\t\t\treturn\n\t\t}\n\t}\n\n\t# Store each entry in the data group line into a local variable\n\tset clientside [getfield $ppass \" \" 1]\n\tset serverside [string trimleft [getfield $ppass \" \" 2 ] \"{\" ]\n\tset newpool [string trimright [getfield $ppass \" \" 3 ] \"}\" ]\n\n\t# If serverside is in the form =match=replace=, apply regex\n\tif {$serverside starts_with \"=\"} {\n\t\tset regex [getfield $serverside \"=\" 2]\n\t\tset rewrite [getfield $serverside \"=\" 3]\n\t\tif {[regexp -nocase $regex \"$orig_host$orig_uri\" 0 1 2 3 4 5 6 7 8 9]}{\n\t\t\t# The clientside becomes the matched string and the serverside the substitution\n\t\t\tset clientside $0\n\t\t\tset serverside [eval set X $rewrite]\n\t\t} else {\n\t\t\tpool $default_pool\n\t\t\treturn\n\t\t}\n\t}\n\n\tif {$clientside starts_with \"/\"} {\n\t\t# No virtual hostname specified, so use the Host header instead\n\t\tset host_clientside $orig_host\n\t\tset path_clientside $clientside\n\t} else {\n\t\t# Virtual host specified in entry, split the host and path\n\t\tset host_clientside [getfield $clientside \"/\" 1]\n\t\tset path_clientside [substr $clientside [string length $host_clientside]]\n\t}\n\t# At this point $host_clientside is the client hostname, and $path_clientside\n\t# is the client-side path as specified in the data group\n\n\tset host_serverside [getfield $serverside \"/\" 1]\n\tset path_serverside [substr $serverside [string length $host_serverside]]\n\tif {$host_serverside eq \"\"} {\n\t\tset host_serverside $host_clientside\n\t}\n\t# At this point $host_serverside is the server hostname, and $path_serverside\n\t# is the server-side path as specified in the data group\n\n\t# In order for directory redirects to work properly we have to be careful with slashes\n\tif {$path_clientside equals \"/\"} {\n\t\t# Make sure serverside path ends with / if clientside path is \"/\"\n\t\tif {!($path_serverside ends_with \"/\")} {\n\t\t\tappend path_serverside \"/\"\n\t\t}\n\t} else {\n\t\t# Otherwise, neither can end in a / (unless serverside path is just \"/\")\n\t\tif {!($path_serverside equals \"/\")} {\n\t\t\tif {$path_serverside ends_with \"/\"} {\n\t\t\t\tset path_serverside [string trimright $path_serverside \"/\"]\n\t\t\t}\n\t\t\tif {$path_clientside ends_with \"/\"} {\n\t\t\t\tset path_clientside [string trimright $path_clientside \"/\"]\n\t\t\t}\n\t\t}\n\t}\n\n\tif { $static::ProxyPassDebug } {\n#\t\tlog local0. \"$log_prefix: Found Rule, Client Host=$host_clientside, Client Path=$path_clientside, Server Host=$host_serverside, Server Path=$path_serverside\"  \n\t}\n\n\t# If you go to http://www.domain.com/dir, and /dir is a directory, the web\n\t# server will redirect you to http://www.domain.com/dir/.  The problem is, with ProxyPass, if the client-side\n\t# path is http://www.domain.com/dir, but the server-side path is http://www.domain.com/, the server will NOT\n\t# redirect the client (it isn't going to redirect you to http://www.domain.com//!).  Here is the problem with\n\t# that.  If there is an image referenced on the page, say logo.jpg, the client doesn't realize /dir is a directory\n\t# and as such it will try to load http://www.domain.com/logo.jpg and not http://www.domain.com/dir/logo.jpg.  So\n\t# ProxyPass has to handle the redirect in this case.  This only really matters if the server-side path is \"/\",\n\t# but since we have the code here we might as well offload all of the redirects that we can (that is whenever\n\t# the client path is exactly the client path specified in the data group but not \"/\").\n\tif {$orig_uri eq $path_clientside} {\n\t\tif {([string index $path_clientside end] ne \"/\") and not ($path_clientside contains \".\") } {\n\t\t\tset is_https 0\n\t\t\tif {[PROFILE::exists clientssl] == 1} {\n\t\t\t\tset is_https 1\n\t\t\t}\n\t\t\t# Assumption here is that the browser is hitting http://host/path which is a virtual path and we need to do the redirect for them\n\t\t\tif {$is_https == 1} {\n\t\t\t\tHTTP::redirect \"https://$orig_host$orig_uri/\"\n\t\t\t\tif { $static::ProxyPassDebug } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Redirecting to https://$orig_host$orig_uri/\"\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tHTTP::redirect \"http://$orig_host$orig_uri/\"\n\t\t\t\tif { $static::ProxyPassDebug } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Redirecting to http://$orig_host$orig_uri/\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tif {$host_clientside eq $orig_host} {\n\t\tif {$orig_uri starts_with $path_clientside} {\n\t\t\tset bypass 0\n\t\t\t# Take care of pool selection\n\t\t\tif {$newpool eq \"\"} {\n\t\t\t\tpool $default_pool\n\t\t\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Using default pool $default_pool\"\n\t\t\t\t}\n\t\t\t\tset newpool $default_pool\n\t\t\t} else {\n\t\t\t\tpool $newpool\n\t\t\t\tif { $static::ProxyPassDebug > 0 } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Using parsed pool $newpool (make sure you have OneConnect enabled)\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t# If we did not match anything, skip the rest of this event\n\tif {$bypass} {\n\t\treturn\n\t}\n\n\t\n}\n\nwhen HTTP_REQUEST_SEND {\n\t# If we didn't match anything, skip the rest of this event\n\tif {$bypass} {\n\t\treturn\n\t}\n\n\t# The following code does the actual rewrite on its way TO \n\t# the backend server. It replaces the URI with the newly \n\t# constructed one and masks the \"Host\" header with the FQDN \n\t# the backend pool server wants to see. \n\t# \n\t# If a new pool or custom SNAT are to be applied, these are \n\t# done here as well. If a SNAT is used, an X-Forwarded-For \n\t# header is attached to send the original requesting IP \n\t# through to the server. \n\n\tif {$host_clientside eq $orig_host} {\n\t\tif {$orig_uri starts_with $path_clientside} {\n\t\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\t\tlog local0. \"$log_prefix: New Host=$host_serverside, New Path=$path_serverside[substr $orig_uri [string length $path_clientside]]\"\n\t\t\t}\n\t\t\tclientside { \n\t\t\t\t# Rewrite the URI\n\t\t\t\tHTTP::uri $path_serverside[substr $orig_uri [string length $path_clientside]]\n\t\t\t\t# Rewrite the Host header\n\t\t\t\tHTTP::header replace Host $host_serverside\n\t\t\t\t# Now alter the Referer header if necessary\n\t\t\t\tif { [HTTP::header exists \"Referer\"] } {\n\t\t\t\t\t set protocol [URI::protocol [HTTP::header Referer]]\n\t\t\t\t\t if {$protocol ne \"\"} {\n\t\t\t\t\t\t  set client_path [findstr [HTTP::header \"Referer\"] $host_clientside [string length $host_clientside]]\n\t\t\t\t\t\t  if {$client_path starts_with $path_clientside} {\n\t\t\t\t\t\t\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\t\t\t\t\t\t\t log local0. \"$log_prefix: Changing Referer header: [HTTP::header Referer] to $protocol://$host_serverside$path_serverside[substr $client_path [string length $path_clientside]]\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tHTTP::header replace \"Referer\" \"$protocol://$host_serverside$path_serverside[substr $client_path [string length $path_clientside]]\"\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t  }\n\t\t}\n\t}\n\n\t# If we're rewriting the response content, prevent the server from using\n\t#\tcompression in its response by removing the Accept-Encoding header\n\t#\tfrom the request.  LTM does not decompress response content before\n\t#\tapplying the stream profile.  This header is only removed if we're\n\t#\trewriting response content.\n\tclientside {\n\t\tif { $static::RewriteResponsePayload } {\n\t\t\tif { [HTTP::header exists \"Accept-Encoding\"] } {\n\t\t\t\tHTTP::header remove \"Accept-Encoding\"\n\t\t\t\tif { $static::ProxyPassDebug > 1} {\n#\t\t\t\t\tlog local0. \"$log_prefix: Removed Accept-Encoding header\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHTTP::header insert \"X-Forwarded-For\" \"[IP::remote_addr]\"\n\t}\t\n}\n\nwhen HTTP_RESPONSE {\n\tif { $static::ProxyPassDebug > 1 } {\n#\t\tlog local0. \"$log_prefix: [HTTP::status] response from [LB::server]\"\n\t}\n\n\tif {$bypass} {\n\t\t# No modification is necessary if we didn't change anything inbound so disable the stream filter if it was enabled\n\n\t\t# Check if we're rewriting the response\n\t\tif {$static::RewriteResponsePayload} {\n\t\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\t\tlog local0. \"$log_prefix: Rewriting response content enabled, but disabled on this response.\"\n\t\t\t}\n\n\t\t\t# Need to explicity disable the stream filter if it's not needed for this response\n\t\t\t# Hide the command from the iRule parser so it won't generate a validation error\n\t\t\t#\twhen not using a stream profile\n\t\t\tset stream_disable_cmd \"STREAM::disable\"\n\n\t\t\t# Execute the STREAM::disable command.  Use catch to handle any errors. Save the result to $result\n\t\t\tif { [catch {eval $stream_disable_cmd} result] } {\n\t\t\t\t# There was an error trying to disable the stream profile.\n#\t\t\t\tlog local0. \"$log_prefix: Error disabling stream filter ($result). If you enable static::RewriteResponsePayload, then you should add a stream profile to the VIP.  Else, set static::RewriteResponsePayload to 0 in this iRule.\"\n\t\t\t}\n\t\t}\n\n\t\t# Exit from this event.\n\t\treturn\n\t}\n\n\t# Check if we're rewriting the response\n\tif {$static::RewriteResponsePayload} {\n\t\t# Configure and enable the stream filter to rewrite the response payload\n\t\t# Hide the command from the iRule parser so it won't generate a validation error\n\t\t#\twhen not using a stream profile\n\t\tif {$static::RewriteResponsePayload > 1} {\n\t\t\tset stream_expression_cmd \"STREAM::expression \\\"@$host_serverside$path_serverside@$host_clientside$path_clientside@ @$path_serverside@$path_clientside@\\\"\"\n\t\t} else {\n\t\t\tset stream_expression_cmd \"STREAM::expression \\\"@$host_serverside$path_serverside@$host_clientside$path_clientside@\\\"\"\n\t\t}\n\t\tset stream_enable_cmd \"STREAM::enable\"\n\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\tlog local0. \"$log_prefix: \\$stream_expression_cmd: $stream_expression_cmd, \\$stream_enable_cmd: $stream_enable_cmd\"\n\t\t}\n\n\t\t# Execute the STREAM::expression command. Use catch to handle any errors. Save the result to $result\n\t\tif { [catch {eval $stream_expression_cmd} result] } {\n\t\t\t# There was an error trying to set the stream expression.\n#\t\t\tlog local0. \"$log_prefix: Error setting stream expression ($result). If you enable static::RewriteResponsePayload, then you should add a stream profile to the VIP.  Else, set static::RewriteResponsePayload to 0 in this iRule.\"\n\t\t} else {\n\t\t\t# No error setting the stream expression, so try to enable the stream filter\n\t\t\t# Execute the STREAM::enable command.  Use catch to handle any errors. Save the result to $result\n\t\t\tif { [catch {eval $stream_enable_cmd} result] } {\n\t\t\t\t# There was an error trying to enable the stream filter.\n#\t\t\t\tlog local0. \"$log_prefix: error enabling stream filter ($result)\"\n\t\t\t} else {\n\t\t\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Successfully configured and enabled stream filter\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t# Fix Location, Content-Location, and URI headers\n\tforeach header {\"Location\" \"Content-Location\" \"URI\"} {\n\t\tset protocol [URI::protocol [HTTP::header $header]]\n\t\tif { $static::ProxyPassDebug > 1 } {\n#\t\t\tlog local0. \"$log_prefix: Checking $header=[HTTP::header $header], \\$protocol=$protocol\"\n\t\t}\n\t\tif {$protocol ne \"\"} {\n\t\t\tset server_path [findstr [HTTP::header $header] $host_serverside [string length $host_serverside]]\n\t\t\tif {$server_path starts_with $path_serverside} {\n\t\t\t\tif { $static::ProxyPassDebug } {\n#\t\t\t\t\tlog local0. \"$log_prefix: Changing response header $header: [HTTP::header $header] with $protocol://$host_clientside$path_clientside[substr $server_path [string length $path_serverside]]\"\n\t\t\t\t}\n\t\t\t\tHTTP::header replace $header $protocol://$host_clientside$path_clientside[substr $server_path [string length $path_serverside]]\n\t\t\t}\n\t\t}\n\t}\n\n\t# Rewrite any domains/paths in Set-Cookie headers\n\tif {[HTTP::header exists \"Set-Cookie\"]}{\n\t\tarray unset cookielist\n\t\tforeach cookievalue [HTTP::header values \"Set-Cookie\"] {\n\t\t\tset cookiename [getfield $cookievalue \"=\" 1]\n\t\t\tset namevalue \"\"\n\t\t\tset newcookievalue \"\"\n\t\t\tforeach element [split $cookievalue \";\"] {\n\t\t\t\tset element [string trim $element]\n\t\t\t\tif {$namevalue equals \"\"} {\n\t\t\t\t\tset namevalue $element\t\n\t\t\t\t} else {\n\t\t\t\t\tif {$element contains \"=\"} {\n\t\t\t\t\t\tset elementname [getfield $element \"=\" 1]\n\t\t\t\t\t\tset elementvalue [getfield $element \"=\" 2]\n\t\t\t\t\t\tif {[string tolower $elementname] eq \"domain\"} {\n\t\t\t\t\t\t\tset elementvalue [string trimright $elementvalue \".\"]\n\t\t\t\t\t\t\tif {$host_serverside ends_with $elementvalue} {\n\t\t\t\t\t\t\t\tif {$static::ProxyPassDebug > 1} {\n#\t\t\t\t\t\t\t\t\tlog local0. \"$log_prefix: Modifying cookie $cookiename domain from $elementvalue to $host_clientside\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tset elementvalue $host_clientside\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tappend elementvalue \".\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif {[string tolower $elementname] eq \"path\"} {\n\t\t\t\t\t\t\tif {$elementvalue starts_with $path_serverside} {\n\t\t\t\t\t\t\t\tif {$static::ProxyPassDebug > 1} {\n#\t\t\t\t\t\t\t\t\tlog local0. \"$log_prefix: Modifying cookie $cookiename path from $elementvalue to $path_clientside[substr $elementvalue [string length $path_serverside]]\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tset elementvalue $path_clientside[substr $elementvalue [string length $path_serverside]]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tappend newcookievalue \"; $elementname=$elementvalue\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tappend newcookievalue \"; $element\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\tset cookielist($cookiename) \"$namevalue$newcookievalue\"\n\t\t}\n\t\tHTTP::header remove \"Set-Cookie\"\n\t\tforeach cookiename [array names cookielist] {\n\t\t\tHTTP::header insert \"Set-Cookie\" $cookielist($cookiename)\n\t\t\tif {$static::ProxyPassDebug > 1} {\n#\t\t\t\tlog local0. \"$log_prefix: Inserting cookie: $cookielist($cookiename)\"\n\t\t\t}\n\t\t}\n\t}\n}\n\n# Only uncomment this event if you need extra debugging for content rewriting.\n# This event can only be uncommented if the iRule is used with a stream profile.\n#when STREAM_MATCHED {\n#\tif { $static::ProxyPassDebug } {\n#\t\tlog local0. \"$log_prefix: Rewriting match: [STREAM::match]\"\n#\t}\n#}\n\n# The following code will look up SSL profile rules from \n# the Data Group ProxyPassSSLProfiles\" and apply \n# them. \n# \n# The format of the entries in this list is as follows: \n# \n# <pool name> <serverssl profile name> \n# \n# All entries are separated by spaces, and both items \n# are required.  The virtual server also will need to\n# have any serverssl profile applied to it for this to work.\nwhen SERVER_CONNECTED { \n\tif {$bypass} {\n\t\treturn\n\t}\n\n\tset class_exists_cmd \"class exists ProxyPassSSLProfiles\"\n\tif {! [eval $class_exists_cmd]} {\n\t\treturn\n\t}\n\n\tset pool [LB::server pool]  \n\n}"
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "app.crm.stackstate.intra_ReverseProxy",
      "partition": "Common",
      "fullPath": "/Common/app.crm.stackstate.intra_ReverseProxy",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~app.crm.stackstate.intra_ReverseProxy?ver=16.1.3",
      "apiAnonymous": "when HTTP_REQUEST {\nif  { [HTTP::host] starts_with \"app.crm.stackstate.intra\" } {\n  switch -glob [HTTP::uri] {\n        \"/ListOfCallsNew*\" {\n            HTTP::header replace Host \"list-of-calls.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/PriceBoxWS*\" {\n            HTTP::header replace Host \"priceboxws.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/async-chat-hazelcast*\" {\n            HTTP::header replace Host \"async-hazelcast.rancherprod-asyncchat-internal.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Async-Chat-Internal_pool\n        }\n        \"/kafka-manager-crm*\" {\n            HTTP::header replace Host \"kafka-manager-crm.rancherprod-middleware.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Middleware-Internal_pool\n        }\n        \"/QM*\" {\n              if { ([HTTP::uri] == \"/QM\") } {\n                  HTTP::uri [string map {\"/QM\" \"/QM/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/qm_pool\n        }\n        \"/TransactionGatewayUI*\" {\n            HTTP::header replace Host \"TransactionGatewayUI.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/TransactionGateway*\" {\n            HTTP::header replace Host \"transactiongateway.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/VoucherGate*\" {\n            HTTP::header replace Host \"voucher-gate.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/addressRepository*\" {\n            HTTP::header replace Host \"address-repository-app.internal-rancherprod-crmdev.prod.stackstate.intra\"\n                #if { ([HTTP::uri] starts_with \"/addressRepository\") } {\n                    #HTTP::uri [string map {\"/addressRepository\" \"/addressRepository/\"} [HTTP::uri]]\n                #}\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/chat-backend*\" {\n            HTTP::header replace Host \"chat-backend.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/chat-backend\") } {\n               HTTP::uri [string map {\"/chat-backend\" \"/chat-backend/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/reappointment-ivr-ussd/management/health*\" {\n            HTTP::header replace Host \"management-health-reappointment-ivr-ussd.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/cimexplorer*\" {\n            pool /CRM/sync/cim_explorer_HTTP_pool\n        }\n        \"/cim-explorer*\" {\n             if { ([HTTP::uri] starts_with \"/cim-explorer\") } {\n               HTTP::uri [string map {\"/cim-explorer\" \"/cimexplorer\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/cim_explorer_HTTP_pool\n        }\n        \"/cimws*\" {\n            pool /CRM/sync/cim_ws_TCP9000_pool\n        }\n\t\t\"/cim*\" {\n\t\t    if { ([HTTP::uri] starts_with \"/cim\") } {\n               HTTP::uri [string map {\"/cim\" \"/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/cim_client_TCP5000_pool\n        }\n        \"/clm*\" {\n            HTTP::header replace Host \"clm.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/consul*\" {\n            HTTP::header replace Host \"consul-erp.rancherprod-middleware.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Middleware-Internal_pool\n        }\n        \"/crmOmyApi*\" {\n            #HTTP::header replace Host \"/crmOmyApi\"\n            pool /CRM/sync/omy-api_pool\n        }\n        \"/data-gathering/*\" {\n            HTTP::header replace Host \"data-gathering-frontend.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            #HTTP::header replace Origin \"http://data-gathering-frontend.rancher-crm-internal.dev.stackstate.intra\"\n            #HTTP::header remove \"X-Forwarded-For\"\n            #HTTP::header insert \"X-Forwarded-For\" [getfield [IP::client_addr] % 1]\n            #HTTP::disable\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/data-gathering-be/*\" {\n            HTTP::header replace Host \"data-gathering-backend.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            #HTTP::header replace Host \"data-gathering-backend.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            #HTTP::header replace Origin \"http://app.crm.stackstate.intra\"\n            #HTTP::header remove \"X-Forwarded-For\"\n            #HTTP::header insert \"X-Forwarded-For\" [getfield [IP::client_addr] % 1]\n            #HTTP::disable\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/email-repo*\" {\n            HTTP::header replace Host \"email-repo.rancherprod-online-internal.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/emailrepo-frontend*\" { \n            HTTP::header replace Host \"emailrepo-frontend.rancherprod-online-internal.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool \n        }\n        \"/email-validation*\" {\n            HTTP::header replace Host \"email-validation.rancherprod-online-internal.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/far-history*\" {\n            HTTP::header replace Host \"far-history.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/kibana-ivrdev*\" {\n            HTTP::header replace Host \"kibana-ivrdev.rancherprod-middleware.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Middleware-Internal_pool\n        }\n        \"/mystackstate-admin*\" {\n            #HTTP::header replace Host \"/mystackstate-admin\"\n            pool /CRM/sync/static_nginx_pool\n        }\n        \"/online-addresses*\" {\n            HTTP::header replace Host \"online-addresses.rancherprod-online-internal.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/opns-admin/*\" {\n            HTTP::header replace Host \"opns-admin.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/payu-connector*\" {\n            HTTP::header replace Host \"payu-connector.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/rancherdev*\" {\n            HTTP::header replace Host \"rancher.rancherdev-internal.dev.stackstate.intra\"\n            pool /CRM/sync/rancher-dev-internal-pool\n        }\n        \"/rms*\" {\n            HTTP::header replace Host \"rms.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/Birt*\" {\n            HTTP::header replace Host \"acrmapps.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/smartlogs*\" {\n            HTTP::header replace Host \"smartlogs.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/rundeck4sales*\" {\n            HTTP::header replace Host \"rundeck4sales.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/salesbo*\" {\n            HTTP::header replace Host \"boss.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/selfServiceBrowser*\" {\n            pool /CRM/sync/selfServiceBrowser_pool\n        }\n        \"/sfa-private*\" {\n            HTTP::header replace Host \"sfa-private.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/sfa-websocket*\" {\n            HTTP::header replace Host \"sfa-websocket.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/sman*\" {\n            HTTP::header replace Host \"sman.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/tax-service*\" {\n            HTTP::header replace Host \"tax-service.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/websragent2buc*\" {\n            HTTP::header replace Host \"/websragent2buc\"\n            pool /CRM/sync/RedundancyAgentBuc_pool\n        }\n        \"/websragent2*\" {\n            HTTP::header replace Host \"/websragent2\"\n            pool /CRM/sync/RedundancyAgent_pool\n        }\n        \"/AcrmDilute*\" {\n            HTTP::header replace Host \"acrmdilute.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/AcrmJitRefreshAPI/*\" {\n            HTTP::header replace Host \"acrmjitrefreshapi.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/AcrmJitWriter*\" {\n            HTTP::header replace Host \"acrmjitwriter.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/AcrmNeckWS*\" {\n            HTTP::header replace Host \"acrmneckws.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/AcrmVantiveProviderAPI*\" {\n            HTTP::header replace Host \"vantiveprovider.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/BatchRunner/*\" {\n            HTTP::header replace Host \"batchrunner.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/DevicesProvider*\" {\n            HTTP::header replace Host \"devicesprovider.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/EshopAdmin-preprod*\" {\n            HTTP::header replace Host \"preprod.eshop-admin-ui.rancher-eshop.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/EshopAdmin*\" {\n            HTTP::header replace Host \"live.eshop-admin-ui.rancher-eshop.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/FixedAssetRecovery*\" {\n            HTTP::header replace Host \"fixed-asset-recovery.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/InstallmentsService*\" {\n            HTTP::header replace Host \"installmentsservice.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/ListOfCallsWeb*\" {\n            HTTP::header replace Host \"list-of-calls-web.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/PhoneUnlocker*\" {\n            HTTP::header replace Host \"phone-unlocker.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/ProxyRetailStockSystem/*\" {\n            HTTP::header replace Host \"proxystocksystem.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/ProxyRetailSystem*\" {\n            HTTP::header replace Host \"proxyretailsystems.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/RecommendationAdvisor*\" {\n            HTTP::header replace Host \"recommendationadvisor.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/SalesFidelityService*\" {\n            HTTP::header replace Host \"salesfidelityservice.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/SmartClientInfo*\" {\n            HTTP::header replace Host \"smartclientinfo.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n\n        \"/AcrmOffers*\" {\n            HTTP::header replace Host \"acrmoffers.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }    \n        \"/SmartHistory*\" {\n            HTTP::header replace Host \"smarthistory.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/business-sms/a2p-sms-backend/actuator/health*\" {\n            HTTP::header replace Host \"management.a2p-sms-backend.rancher-a2psms.prod.stackstate.intra\"\n\t\t\tif { ([HTTP::uri] starts_with \"/business-sms/a2p-sms-backend/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/a2p-sms-backend/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/email2sms/actuator/health*\" {\n            HTTP::header replace Host \"management.email2sms.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/email2sms/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/email2sms/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/fleet-subscriber-updates/actuator/health*\" {\n            HTTP::header replace Host \"management.fleet-subscriber-updates.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/fleet-subscriber-updates/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/fleet-subscriber-updates/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/import-destinations/actuator/health*\" {\n            HTTP::header replace Host \"management.import-destinations.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/import-destinations/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/import-destinations/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/process-mo-sms/actuator/health*\" {\n            HTTP::header replace Host \"management.process-mo-sms.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/process-mo-sms/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/process-mo-sms/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/process-sms-status/actuator/health*\" {\n            HTTP::header replace Host \"management.process-sms-status.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/process-sms-status/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/process-sms-status/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/retry-mt-sms/actuator/health*\" {\n            HTTP::header replace Host \"management.retry-mt-sms.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/retry-mt-sms/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/retry-mt-sms/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/run-billing/actuator/health*\" {\n            HTTP::header replace Host \"management.run-billing.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/run-billing/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/run-billing/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/run-mt-campaign/actuator/health*\" {\n            HTTP::header replace Host \"management.run-mt-campaign.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/run-mt-campaign/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/run-mt-campaign/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/send-email/actuator/health*\" {\n            HTTP::header replace Host \"management.send-email.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/send-email/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/send-email/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/business-sms/send-mt-sms/actuator/health*\" {\n            HTTP::header replace Host \"management.send-mt-sms.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/send-mt-sms/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/send-mt-sms/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n\t\t\"/business-sms/write-cdr/actuator/health*\" {\n            HTTP::header replace Host \"management.write-cdr.rancher-a2psms.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/business-sms/write-cdr/actuator/health/\") } {\n                  HTTP::uri [string map {\"/business-sms/write-cdr/actuator/health/\" \"/business-sms/actuator/health/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-A2PSMS-Internal_pool\n        }\n        \"/catalog-service*\" {\n            HTTP::header replace Host \"catalog-service.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/changeItemDefinition*\" {\n            HTTP::header replace Host \"change-item-definition.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/clientFinancialView*\" {\n            HTTP::header replace Host \"client-financial-view.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n\n        \"/databaseExplorer*\" {\n            HTTP::header replace Host \"database-explorer.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            if { ([HTTP::uri] == \"/databaseExplorer\") } {\n               HTTP::uri [string map {\"/databaseExplorer\" \"/databaseExplorer/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n\n        \"/preview-plata-factura*\" {\n            HTTP::header replace Host \"preview-explorer-webpay.rancher-explorer.prod.stackstate.intra\"\n            if { ([HTTP::uri] == \"/preview-plata-factura\") } {\n               HTTP::uri [string map {\"/preview-plata-factura\" \"/preview-plata-factura/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\t\n\n        \"/platformsInstalledServicesWeb*\" {\n            HTTP::header replace Host \"platforms-installed-services.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            if { ([HTTP::uri] == \"/platformsInstalledServicesWeb\") } {\n               HTTP::uri [string map {\"/platformsInstalledServicesWeb\" \"/platformsInstalledServicesWeb/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/subscriberOffer*\" {\n            HTTP::header replace Host \"subscriber-offer.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            if { ([HTTP::uri] == \"/subscriberOffer\") } {\n               HTTP::uri [string map {\"/subscriberOffer\" \"/subscriberOffer/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/surveyInterface*\" {\n            HTTP::header replace Host \"survey-interface.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/surveyInterface\") } {\n               HTTP::uri [string map {\"/surveyInterface\" \"/surveyInterface/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/eshop-reshape/cart/actuator/*\" {\n            HTTP::header replace Host \"eshopb2c-cartv2-management.rancher-eshopb2c.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop-reshape/cart/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop-reshape/cart/actuator/\" \"/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-EShopB2C-Internal_pool\n        }\n        \"/eshop-reshape/personalization-engine/actuator/*\" {\n            HTTP::header replace Host \"eshopb2c-personalization-engine-management.rancher-eshopb2c.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop-reshape/personalization-engine/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop-reshape/personalization-engine/actuator/\" \"/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-EShopB2C-Internal_pool\n        }\n        \"/eshop-reshape/product-indexer/actuator/*\" {\n            HTTP::header replace Host \"eshopb2c-product-indexer-management.rancher-eshopb2c.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop-reshape/product-indexer/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop-reshape/product-indexer/actuator/\" \"/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-EShopB2C-Internal_pool\n        }\n        \"/eshop-reshape/product-service/actuator/*\" {\n            HTTP::header replace Host \"eshopb2c-product-service-management.rancher-eshopb2c.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop-reshape/product-service/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop-reshape/product-service/actuator/\" \"/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-EShopB2C-Internal_pool\n        }\n\n        \"/eshopb2c-search*\"  { \n\t\t    set orig_uri \"[HTTP::uri]\"\n\t\t    HTTP::uri \"/webshop-[substr $orig_uri 10]\"\n\t    \tHTTP::header replace Host \"eshopb2c-web-search.rancher-eshopb2c.prod.stackstate.intra\"\n\t\t    pool /CRM/sync/RancherProd-EShopB2C-Internal_pool\n        }\n\n        \"/eshop/api-gateway/management/*\" {\n            HTTP::header replace Host \"management-health-api-gateway.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/api-gateway/management/\") } {\n                  HTTP::uri [string map {\"/eshop/api-gateway/management/\" \"/eshop/management/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/availability*\" {\n            HTTP::header replace Host \"management-health-global-eshopb2b.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/availability/\") } {\n                  HTTP::uri [string map {\"/eshop/availability/\" \"/eshop-b2b/actuator/health\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/bff/actuator/*\" {\n            HTTP::header replace Host \"management-health-bff.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/bff/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/bff/actuator/\" \"/bff/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/cart/actuator/*\" {\n            HTTP::header replace Host \"management-health-cart.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/cart/actuator\") } {\n                  HTTP::uri [string map {\"/eshop/cart/actuator/\" \"/cart/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/offer-service/actuator/*\" {\n            HTTP::header replace Host \"management-health-offer-service.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/offer-service/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/offer-service/actuator/\" \"/offer-service/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/order-management/actuator/*\" {\n            HTTP::header replace Host \"management-health-order-management.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/order-management/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/order-management/actuator/\" \"/order-management/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/payment-service/actuator/*\" {\n            HTTP::header replace Host \"management-health-payment-service.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/payment-service/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/payment-service/actuator/\" \"/payment-service/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/resource-transfer/actuator/*\" {\n            HTTP::header replace Host \"management-health-resource-transfer.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/resource-transfer/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/resource-transfer/actuator/\" \"/resource-transfer/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/stock-service/actuator/*\" {\n            HTTP::header replace Host \"management-health-stock-service.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/stock-service/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/stock-service/actuator/\" \"/stock-service/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/eshop/webshop-search-engine/actuator/*\" {\n            HTTP::header replace Host \"management-health-webshop-search-engine.rancher-eshop.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/eshop/webshop-search-engine/actuator/\") } {\n                  HTTP::uri [string map {\"/eshop/webshop-search-engine/actuator/\" \"/webshop-search/actuator/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Eshop-Internal_pool\n        }\n        \"/explorer-billing/admin*\" {\n            HTTP::header replace Host \"explorer-billing.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-billing/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-billing.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-cms-ui/management/health*\" {\n            HTTP::header replace Host \"explorer-cmsui.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-cms-ui/*\" {\n            HTTP::header replace Host \"explorer-cmsui.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-cms/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-cms.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-cms/*\" {\n            HTTP::header replace Host \"explorer-cms.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-gateway/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-gateway.rancher-explorer.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/explorer-gateway/management/\") } {\n                  HTTP::uri [string map {\"/explorer-gateway/management/\" \"/management/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-onboarding/admin/v1*\" {\n            HTTP::header replace Host \"explorer-onboarding.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-onboarding/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-onboarding.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-payment/admin/v1/payments*\" {\n            HTTP::header replace Host \"explorer-payment.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-payment/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-payment.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n         \"/explorer-user/admin*\" {\n            HTTP::header replace Host \"explorer-user.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/explorer-user/admin\") } {\n               HTTP::uri [string map {\"/explorer-user/admin\" \"/explorer-user/admin\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/explorer-user/management/*\" {\n            HTTP::header replace Host \"management-health-explorer-user.rancher-explorer.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n\n        \"/frc-dynamic-omy*\" {\n            HTTP::header replace Host \"frc-dynamic-omy.rancher-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/frc-dynamic-omy\") } {\n               HTTP::uri [string map {\"/frc-dynamic-omy\" \"/frc-dynamic-omy/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/frc-dynamic*\" {\n            HTTP::header replace Host \"frc-dynamic.rancher-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/frc-dynamic\") } {\n               HTTP::uri [string map {\"/frc-dynamic\" \"/frc-dynamic/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n         \"/frc-frontend-omy*\" {\n            HTTP::header replace Host \"frc-frontend-omy.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/frc-frontend-omy\") } {\n               HTTP::uri [string map {\"/frc-frontend-omy\" \"/frc-frontend-omy/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }        \n        \"/frc-frontend*\" {\n            HTTP::header replace Host \"frc-frontend-dynamic.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/frc-frontend\") } {\n               HTTP::uri [string map {\"/frc-frontend\" \"/frc-frontend/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/frc*\" {\n            HTTP::header replace Host \"frc-frontend.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }   \n        \"/omy-frc*\" {\n            HTTP::header replace Host \"frc-static-omy.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }        \n        \"/ftthOrderBrowser*\" {\n            HTTP::header replace Host \"ftth-order-browser.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/ftthOrderBrowser\") } {\n               HTTP::uri [string map {\"/ftthOrderBrowser\" \"/ftthOrderBrowser/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/crminterface*\" {\n            HTTP::header replace Host \"crm-interface.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/crminterface\") } {\n               HTTP::uri [string map {\"/crminterface\" \"/crminterface/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/crmfrontends*\" {\n            HTTP::header replace Host \"crm-frontends.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/crmfrontends\") } {\n               HTTP::uri [string map {\"/crmfrontends\" \"/crmfrontends/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n\n        \"/interactionsWebApp*\" {\n            HTTP::header replace Host \"interactions-web.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/interactionsWebApp\") } {\n               HTTP::uri [string map {\"/interactionsWebApp\" \"/interactionsWebApp/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/bulkImport*\" {\n            HTTP::header replace Host \"bulk-import.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/bulkImport\") } {\n               HTTP::uri [string map {\"/bulkImport\" \"/bulkImport/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/tkrOrderBrowser*\" {\n            HTTP::header replace Host \"tkr-order-browser.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/tkrOrderBrowser\") } {\n               HTTP::uri [string map {\"/tkrOrderBrowser\" \"/tkrOrderBrowser/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/cashierTransactions*\" {\n            HTTP::header replace Host \"cashier-transactions.internal-rancherprod-crmdev.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/cashierTransactions\") } {\n               HTTP::uri [string map {\"/cashierTransactions\" \"/cashierTransactions/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/gamification*\" {\n            HTTP::header replace Host \"mystackstate-gamification.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/ivrincidentalarm*\" {\n            HTTP::header replace Host \"ivr-incident-alarm.internal-rancherprod-crmdev.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/ivrtaxv2*\" {\n            HTTP::header replace Host \"/ivrtaxv2\"\n            pool /CRM/sync/Ivr_taxation_v2_pool\n        }\n        \"/ivr*\" {\n            HTTP::header replace Host \"/ivr\"\n            pool /CRM/sync/sipivr_pool\n        }\n        \"/mgmt-gamification*\" {\n            HTTP::header replace Host \"management-health-mystackstate-gamification.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/mgmt-gamification\") } {\n                  HTTP::uri [string map {\"/mgmt-gamification/\" \"/gamification/management/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/mgmt-mystackstate-gateway*\" {\n            HTTP::header replace Host \"management-health-mystackstate-gateway.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] starts_with \"/mgmt-mystackstate-gateway/\") } {\n                  HTTP::uri [string map {\"/mgmt-mystackstate-gateway/\" \"/management/\"} [HTTP::uri]]\n                 }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/myaccount-corporate-manage*\" {\n            HTTP::header replace Host \"myaccount-corporate-manage.rancher-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-MyAccount-B2B-Internal_pool\n        }\n        \"/mystackstate-opns-adapter*\" {\n            HTTP::header replace Host \"mystackstate-opns-adapter.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/netflix/actuator/health*\" {\n            HTTP::header replace Host \"management-health-netflix-connector.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/netflix*\" {\n            HTTP::header replace Host \"netflix-connector.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/opns-admin*\" {\n            HTTP::header replace Host \"opns-admin.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/opns-inbox*\" {\n            HTTP::header replace Host \"opns-inbox.rancherprod-online-internal.prod.stackstate.intra\"\n            if { ([HTTP::uri] == \"/opns-inbox\") } {\n               HTTP::uri [string map {\"/opns-inbox\" \"/opns-inbox/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n\n        \"/stackstate-exchange/management/health*\" {\n            HTTP::header replace Host \"management-health-stackstate-exchange.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/orderCaptureWeb*\" {\n            HTTP::header replace Host \"order-capture-web.internal-rancherprod-crmdev.prod.stackstate.intra\"\n               if { ([HTTP::uri] == \"/orderCaptureWeb\") } {\n               HTTP::uri [string map {\"/orderCaptureWeb\" \"/orderCaptureWeb/\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/vhbb-ordercapture-web*\" {\n            HTTP::header replace Host \"vhbb-ordercapture-web.internal-rancherprod-crmdev.prod.stackstate.intra\"\n               if { ([HTTP::uri] == \"/vhbb-ordercapture-web\") } {\n               HTTP::uri [string map {\"/vhbb-ordercapture-web\" \"/vhbb-ordercapture-web/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-CRMDev-Internal_pool_52\n        }\n        \"/preview-explorer-billing/admin*\" {\n            HTTP::header replace Host \"preview-explorer-billing.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-billing/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-billing/admin\" \"/explorer-billing/admin\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/preview-explorer-cms/admin*\" {\n            HTTP::header replace Host \"preview-explorer-cms.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-cms/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-cms/admin\" \"/explorer-cms/admin\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/preview-explorer-cms-ui/admin*\" {\n            HTTP::header replace Host \"preview-explorer-cmsui.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-cms-ui/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-cms-ui/admin\" \"/explorer-cms-ui/admin\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/preview-explorer-onboarding/admin*\" {\n            HTTP::header replace Host \"preview-explorer-onboarding.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-onboarding/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-onboarding/admin\" \"/explorer-onboarding/admin\"} [HTTP::uri]]\n              }              \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/preview-explorer-payment/admin/v1/payments*\" {\n            HTTP::header replace Host \"preview-explorer-payment.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-payment/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-payment/admin\" \"/explorer-payment/admin\"} [HTTP::uri]]\n              }                \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n         \"/preview-explorer-user/admin*\" {\n            HTTP::header replace Host \"preview-explorer-user.rancher-explorer.prod.stackstate.intra\"\n               if { ([HTTP::uri] starts_with \"/preview-explorer-user/admin\") } {\n               HTTP::uri [string map {\"/preview-explorer-user/admin\" \"/explorer-user/admin\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Explorer-Internal_pool\n        }\n        \"/sov*\" {\n            HTTP::header replace Host \"sov-backend.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/statisticsservice*\" {\n            HTTP::header replace Host \"statisticsservice.rancher-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/togglz-console*\" {\n            HTTP::header replace Host \"ows-router-togglz.rancherprod-online.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/UserProfile*\" {\n            HTTP::header replace Host \"user-profile.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/epos-notify*\" {\n            HTTP::header replace Host \"epos-notify.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/wallet-dynamic-omy*\" {\n            HTTP::header replace Host \"wallet-dynamic-omy.rancher-online.prod.stackstate.intra\"\n              #if { ([HTTP::uri] == \"/wallet-dynamic-omy\") } {\n               #HTTP::uri [string map {\"/wallet-dynamic-omy\" \"/wallet-dynamic-omy/\"} [HTTP::uri]]\n              #}\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/wallet-dynamic*\" {\n            HTTP::header replace Host \"wallet-dynamic.rancher-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/wallet-dynamic\") } {\n               HTTP::uri [string map {\"/wallet-dynamic\" \"/wallet-dynamic/\"} [HTTP::uri]]\n              }\n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/wallet*\" {\n            HTTP::header replace Host \"ows-frontend.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/wallet\") } {\n               HTTP::uri [string map {\"/wallet\" \"/wallet/\"} [HTTP::uri]]\n              }            \n            pool /CRM/sync/RancherProd-Online-Internal_pool\n        }\n        \"/omy-wallet*\" {\n           HTTP::header replace Host \"ows-static-omy.rancherprod-online.prod.stackstate.intra\"\n              if { ([HTTP::uri] == \"/omy-wallet\") } {\n               HTTP::uri [string map {\"/omy-wallet\" \"/omy-wallet/\"} [HTTP::uri]]\n              }              \n           pool /CRM/sync/RancherProd-Online-Internal_pool \n        }\n        \"/eservice-api-gateway*\" {\n            HTTP::header replace Host \"eservice-api-gateway.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/eservice-thirds-ws*\" {\n            HTTP::header replace Host \"eservice-thirds-ws.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n        \"/wfm*\" {\n            HTTP::header replace Host \"wfm.rancher-sales.prod.stackstate.intra\"\n            pool /CRM/sync/RancherProd-Sales-Internal_pool\n        }\n      #\"/sfa/api/nirvana*\" { #pool /CRM/sync/temporarysfa_4sale }\n      \"/ppyregistration*\" { pool /CRM/sync/ppyRegistration_plain_pool }\n      #\"/pfm*\" {\n         #HTTP::header replace Host \"crmsupport.office.stackstate.intra\"\n         #pool /CRM/sync/crmsupport_pool\n      #}\n      \"/Crm2Iwd*\" { \n         set orig_uri \"[HTTP::uri]\"\n         pool /CRM/sync/Crm2Iwd_pool\n         HTTP::uri \"/Genesys[substr $orig_uri 8]\"\n         ##log local0. \"crm2iwd- end [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri]\"\n       } \n       #\"/zipkin*\" { #pool /CRM/sync/Rancher-Online-Internal_pool }\n       \"/AdvahooMainApp*\" { \n               persist cookie;\n               pool /CRM/sync/transfond_test_pool \n       } \n      \"/clapham*\" { \n         #log local0. \"Clapham used [HTTP::host] and requested [HTTP::uri]\";\n         pool /CRM/sync/clapham_pool;\n      }\n\n      \"/fabric*\" {\n         persist none; \n         pool /CRM/sync/fabric_pool;\n      }\n\n      \"/stackstatePOS*\" {\n         persist none;\n         pool /CRM/sync/stackstatePOS_pool;\n      }\n\n      \"/stg-admin*\" {\n         persist none;\n         pool /CRM/sync/stg-admin_pool;\n      }\n\n      \"/IWSCrmService*\" { pool /CRM/sync/iwssrvsip_pool }\n\n      \"/ssi*\" { pool /CRM/sync/scanningsolution_ssi }\n      \"/money-codes*\" { \n         persist cookie;\n          pool /CRM/sync/money-codes_pool \n      }\n      #\"/ClusterWebApp*\" {\n        #HTTP::header remove \"X-Forwarded-For\";\n        #HTTP::header insert \"X-Forwarded-For\" [substr [IP::client_addr] 0 \"%\"];\n        #pool /CRM/sync/jboss7devCloudCrmOnline_pool;\n      #}\n\n      \"/selfServiceBrowser/*\" {\n       if { [active_members /CRM/sync/selfServiceBrowser_pool] == 0 } { \n          HTTP::redirect \"http://www.stackstate.ro/ups.html\" \n      } \n     #   HTTP::uri [substr [HTTP::uri] 19];\n     #   pool /CRM/sync/selfServiceBrowser_pool\n     }\n     \"/InvoiceBrowser*\" { \n       persist none;\n       # log local0. \"InvoiceBrowser2 used [HTTP::host] and requested [HTTP::uri]\"\n       pool /CRM/sync/InvoiceBrowser_pool; \n     }\n     \"/reminder_rescheduler*\" { HTTP::redirect \"http://ixkun.crm.stackstate.intra/scripts/invoice_reminder/\" }\n\n     \"/userprofile2*\" {\n         HTTP::redirect \"http://userman.office.stackstate.intra/users/userprofile.py/main\";\n         pool /CRM/sync/userman_office_pool; \n      }\n\n     \"/userprofile*\" {\n         HTTP::redirect \"http://userman.office.stackstate.intra/users/userprofile.py/main\";\n         pool /CRM/sync/userman_office_pool; \n      }\n\n     \"/scripts/users*\" { \n         HTTP::redirect \"http://userman.office.stackstate.intra/users/userprofile.py/main\";\n         }\n\n     \"/csdalarms*\" {\n         #HTTP::redirect \"http://app.crm.stackstate.intra/scripts/csdalarms/main.py/main\";\n         HTTP::redirect \"http://crmsupport.office.stackstate.intra/OpenAlarmCRM/index.php\";\n         #pool /CRM/sync/ixkun.crm.stackstate.intra_80_pool; \n      }\n\n     \"/CE*\" {\n         #HTTP::redirect \"http://crmsupport.office.stackstate.intra/CE/\";\n         pool /CRM/sync/monitorizare_CE; \n      }\n\n     \"/users*\" { pool /CRM/sync/userman_office_pool; }\n     #\"/scripts/*\" { #pool /CRM/sync/ixkun.crm.stackstate.intra_80_pool; }\n\n\n\n   \"/stackstate-messages-flows*\" { \n      persist none;\n      pool /CRM/sync/mdm_pool;\n      # log local0. \"MDM - end [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri]\";\n    }\n   #\"/PriceBox\" { \n      #persist cookie;\n      #pool /CRM/sync/PriceBox_pool;\n      # log local0. \"PriceBox - end [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri] and destination [server_addr]:[server_port]\";\n    #}\n\n   #\"/PriceBox/*\" { \n      #pool /CRM/sync/PriceBox_pool;\n      # log local0. \"PriceBox - end [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri] and destination [server_addr]:[server_port]\";\n    #}\n    \n    \n    \"/PriceBox*\" {\n       if { [HTTP::uri] equals \"/PriceBox\" } {\n           HTTP::uri \"/PriceBox/\"\n       }\n       HTTP::header replace Host \"pricebox.rancher-sales.prod.stackstate.intra\"\n       pool /CRM/sync/RancherProd-Sales-Internal_pool\n    }\n    \n    #\"/PriceBox*\" {\n    #    HTTP::header replace Host \"pricebox.rancher-sales.prod.stackstate.intra\"\n    #    if { ([HTTP::uri] starts_with \"/PriceBox\") } {\n    #        HTTP::uri [string map {\"/PriceBox\" \"/PriceBox/\"} [HTTP::uri]]\n    #    }            \n    #    pool /CRM/sync/RancherProd-Sales-Internal_pool\n    #}\n\n   \"/device-center*\" { pool /CRM/sync/device_center_pool }\n\n   #\"/services/JitGeneratorService*\" { \n      #persist none;\n      #pool /CRM/sync/JitGeneratorService_pool; \n   #}\n\n  #\"/AcrmNeckWS*\" { \n  #Disables.by.Dan.Diaconu.20190927.migrat.in.docker\n  #persist none;\n  #pool /CRM/sync/AcrmNeckWS_spring_pool; \n  #}\n\n   \"/selfcareoverussd*\" { \n      persist none;\n   }\n\n   #\"/ProxyRetailSystem*\" { \n   #Disabled.by.Dan.Diaconu.migrat.in.docker.18.06.2020\n   #    persist none;\n   #    pool /CRM/sync/ProxyRetailSystem_jar_pool; \n   #}\n\n   #\"/AcrmJitRefreshAPI*\" {\n   #Dan.Diaconu.migrat la docker via proxypass  \n   #persist none;\n   #pool /CRM/sync/AcrmJitRefreshRest_pool;\n   #}\n   #\"/AcrmVantiveProviderAPI*\" { \n   #Dan.Diaconu migrat la docker in 31.03.2020\n   #    persist none;\n   #    pool /CRM/sync/AcrmVantiveProviderAPI_pool;\n   #}\n   #\"/RecommendationAdvisor*\" {\n   #    pool /CRM/sync/RecommendationAdvisor_pool\n   #}\n   #\"/SmartClientInfo*\" { \n   #    pool /CRM/sync/SmartClientInfo_pool;\n   #}\n   \"/ImeiCatcher*\" { \n       persist none;\n       pool  /CRM/sync/ImeiCatcher_pool;\n   }\n   \"/imeiProxyService*\" { \n       persist none;\n       pool  /CRM/sync/ImeiCatcher_pool;\n   }  \n   \"/CTIInteractionExplorer*\" { \n       pool /CRM/sync/CTIInteractionExplorer_pool; \n     }\n    \"/attachmentsexplorer*\" { \n       pool /CRM/sync/attachments_explorer_pool; \n     }\n   \"/BdefenderMobileSecApi*\" {\n      pool /CRM/sync/BdefenderMobileSecApi_pool ;\n   }\n   \"/CardDeclaration*\" {\n      pool /CRM/sync/CardDeclaration_pool ;\n   }\n   \"/OroTemplatesWS*\" { pool /CRM/sync/OroTemplatesWS_pool } \n   \"/OroTemplates*\" { pool /CRM/sync/OroTemplates_pool }\n   #\"/MobileDataCallCenter*\" { #pool /CRM/sync/MobileDataCallCenter_pool }\n   \"/databaseexplorer*\" { pool /CRM/sync/databaseExplorer_spring_pool }\n   \"/taskScheduler*\" {\n              #log local0. \"taskscheduler - end [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri]\"; \n              pool /CRM/sync/task_scheduler_pool;\n    }\n   \"/Appointment*\" { \n      #log local0. \"dddddd used [HTTP::host] and requested [HTTP::uri]\" \n      pool /CRM/sync/ArgoAppointmentManager_pool ;\n    }\n   \"/apia*\" {pool /CRM/sync/ApiaJboss7_pool}\n   \"/OCS20*\" { pool /CRM/sync/OCS20_pool }\n   \"/DCOReports*\" { pool /CRM/sync/DCOReports_pool }\n   \"/Salt*\" { pool /CRM/sync/Salt_pool } \n   #\"/eLabeling*\" { pool /CRM/sync/eLabeling_pool }\n   #\"/eLabeling*\" { pool /CRM/sync/eLabeling_standalone_pool }\n   \"/eLabeling*\" {\n        if { [HTTP::uri] equals \"/eLabeling\" } {\n           HTTP::uri \"/eLabeling/\"\n        }\n        HTTP::header replace Host \"elabeling.rancher-sales.prod.stackstate.intra\"\n        pool /CRM/sync/RancherProd-Sales-Internal_pool\n   }\n   #\"/AcrmOffers*\" { pool /CRM/sync/AcrmOffers }\n   \"/AcrmMsgServices*\" { pool /CRM/sync/AcrmMsgServices_pool }\n   \"/niagara*\" { pool /CRM/sync/niagara_pool }\n   \"/interaction*\" { pool /CRM/sync/interactionWS_pool } \n   \"/clientcheck/*\" { pool /CRM/sync/interactionWS_pool }  \n   #\"/ext*\" { \n      #link folosit de aplicatia niagara\n      #pool /CRM/sync/niagara_pool \n   #}\n      #\"/wallet/*\" {\n         #persist none;\n         #pool /CRM/sync/ows_pool\n      #} \n   #\"/VantiveDocumentGenerator*\" { #pool /CRM/sync/VantiveDocumentGenerator_pool }\n   \"/document-generator*\" { pool /CRM/sync/DocumentGenerator_pool }\n   #\"/PromoGate*\" { #pool /CRM/sync/PromoGate_pool }\n   \"/LoyaltyHistory*\" { pool /CRM/sync/LoyaltyHistory_pool }\n   #\"/BatchRunner*\" { #pool /CRM/sync/BatchRunner_pool }  \n   #\"/gatheringTool*\" { pool /CRM/sync/GatheringTool_pool  } \n   \"/gatheringTool*\" { \n   HTTP::header replace Host \"gatheringtool.rancher-sales.prod.stackstate.intra\"\n   HTTP::header replace \"Origin\" \"http://gatheringtool.rancher-sales.prod.stackstate.intra\"\n   pool /CRM/sync/RancherProd-Sales-Internal_pool;\n   }\n   \"/oaes*\" { pool /CRM/sync/oaesboris_pool  } \n   \"/BillingProvisioningApi*\" { pool /CRM/sync/BillingProvisioningApi_pool  }  \n   #\"/UserProfile*\" { pool /CRM/sync/UserProfileService_pool }\n   \"/smartsales*\" { pool /CRM/sync/smartsales_pool }\n   \"/BudgetService*\" { pool /CRM/sync/budgetService_pool } \n   \"/boss*\" { pool /CRM/sync/boss_pool }\n   #\"/AcrmJitWriter*\" { #pool /CRM/sync/AcrmJitWriter_pool }\n   #\"/AcrmDilute/1.1/*\" { #pool /CRM/sync/AcrmDilute_pool }\n   #\"/AcrmDilute*\" { #pool /CRM/sync/AcrmDilute_pool }\n   \"/groupsimulation*\" { pool /CRM/sync/groupsimulation_pool }\n   #\"/eastersimulation*\" { #pool /CRM/sync/eastersimulation }\n   \"/azkaban*\" { pool /CRM/sync/azkaban_pool }\n   \"/sfa-private*\" { }\n   \"/sfa-websocket*\" { }\n   \"/sfa4buss*\" { pool /CRM/sync/sfa4buss_pool }\n   \"/sfa*\" { \n    #log local0. \"SFA_ANDREIE_TEST [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri] and requesting file [URI::basename [HTTP::path]]\"\n    pool /CRM/sync/sfa_4sales_pool \n   }\n   \"/ListOfCalls/*\" { pool /CRM/sync/ListOfCalls_pool }\n   \"/ListOfCallsAPI*\" { pool /CRM/sync/ListOfCallsAPI_pool }\n   \"/caponeService*\" { pool /CRM/sync/caponeService }\n   \"/DeviceCustodyService*\" { pool /CRM/sync/DeviceCustodyService_pool }\n   \"/axis/services/RoamwareService*\" { pool /CRM/sync/RoamwareWS_pool }\n   #\"/JobRepository*\" { #pool /CRM/sync/JobRepository_pool }\n   \"/tkrappointmentinfo*\" { pool /CRM/sync/tkrappointmentinfo_pool }\n   \"/platformsInstalledServices/*\" { pool /CRM/sync/PlatformsInstalledServicesWebapp_pool }\n   \"/crmLoyaltyApplication*\" { pool /CRM/sync/crmLoyaltyApplication_pool }\n   \"/stackstateAddresses*\" {\n       persist none;\n       pool /CRM/sync/stackstate_addresses_pool;\n    }\n   \"/stackstateAddressImporter*\" { pool /CRM/sync/stackstate_address_importer_pool }\n   \"/operationalreports/health\" { pool /CRM/sync/operationalReports_health_pool }\n   \"/addressbrowser/health\" { pool /CRM/sync/addressBrowser_health_pool }\n   \"/addressbrowser*\" { pool /CRM/sync/addressBrowser_pool } \n   \"/sales2crm*\" { \n       persist none;\n       pool /CRM/sync/sales2crm_pool;\n    }\n   \"/selfcaretester*\" { pool /CRM/sync/selfcaretester_pool }\n   \"/SelfcareBanners*\" { pool /CRM/sync/selfcare_banners_pool }\n   \"/crmLoyaltyWebApplication*\" { pool /CRM/sync/LoyaltyWebApp_pool }\n   \"/operationalreports*\" { pool /CRM/sync/operationalReports_pool }\n   #\"/oasisweb/vantive*\" {\n      #HTTP::uri [substr [HTTP::uri] 9]\n      #pool /CRM/sync/oasisweb_pool\n   #}\n   #\"/PhoneUnlocker/*\" { #pool /CRM/sync/phoneUnlocker_pool }\n   \"/ordercapture*\" { pool /CRM/sync/ordercapture_pool }\n   \"/apex*\" { pool /CRM/sync/AcrmInbound_pool } \n   \"/addressRelations*\" { pool /CRM/sync/AddressRelations_pool }\n   \"/PaymentInterface*\" {pool /CRM/sync/PaymentInterface_pool }\n   #\"/FixedAssetRecovery*\" { #pool /CRM/sync/FixedAssetRecovery_pool }\n   \"/customerpreferences*\" { pool /CRM/sync/CustomerPreferences_pool }\n   \"/customerPreferences*\" { pool /CRM/sync/customerPreferences_pool }\n   \"/otpSimChange*\" { pool /CRM/sync/otpSimChange_pool }\n   #\"/Scoring*\" { #pool /CRM/sync/Scoring_4sales_pool }\n   \"/CustomerRiskService*\" { pool /CRM/sync/Scoring_4sales_pool }\n   #\"/Incidente*\" { #pool /CRM/sync/Incidente_pool }\n   \"/customerHierarchy*\" { pool /CRM/sync/customerHierarchy_pool}\n   \"/customerhierarchy*\" { pool /CRM/sync/CustomerHierarchyWS_pool }\n   \"/inboxbrowser*\" { pool /CRM/sync/inboxbrowser_pool }\n   \"/jitMessageProducer/*\" { pool /CRM/sync/JitMessageProducer_pool }\n   \"/jitMessageProducer_vhbb/*\" { pool /CRM/sync/JitMessageProducerVHBB_pool }\n   \"/argo/v1*\" { pool /CRM/sync/ArgoCore_pool }\n   \"/WrapperService*\" { pool /CRM/sync/WrapperService_pool }\n   \"/TransactionGatewayUI*\" { pool /CRM/sync/RancherProd-Sales-Internal_pool }\n   \"/TransactionGateway*\" { pool /CRM/sync/RancherProd-Sales-Internal_pool }\n   \"/TransactionGateway/*\" { pool /CRM/sync/RancherProd-Sales-Internal_pool }\n   \"/chat/*\" { pool /CRM/sync/ChatBotAPI_pool } \n   \"/crmprofilesdesigner*\" { pool /CRM/sync/CRMProfilesDesigner_pool }\n   \"/clientprofiler*\" { pool /CRM/sync/ClientProfiler_pool }\n   #\"/clientFinancialView*\" { #pool /CRM/sync/clientFinancialView_pool }\n   \"/consentApp*\" { pool /CRM/sync/consentapp_pool }\n   \"/StockReservationInterface*\" { pool /CRM/sync/StockReservation_pool }\n   \"/InboxRouter*\" { pool /CRM/sync/InboxRouter_pool }\n   \"/bonusAllocation*\" { pool /CRM/sync/bonus_allocator_pool }\n   \"/esimprofileapp*\" { pool /CRM/sync/esim_smdp_pool }\n   \"/agreementApp*\"   { pool /CRM/sync/AgreementApp_pool }\n   \"/ProvisioningGateway/api/v1*\" { pool /CRM/sync/provisioningGateway_pool }\n   #\"/agreementApp*\" {#pool /CRM/sync/agreementApp_pool }\n   \"/changeengine/*\" {pool /CRM/sync/ChangeEngine_pool }\n   \"/changeengine_vhbb/*\" {pool /CRM/sync/ChangeEngineVHBB_pool }\n   \"/batchdispenser*\" { pool /CRM/sync/BatchDispenser_pool }\n   \"/multisimapp*\" { pool /CRM/sync/MultiSimApp_pool }\n   \"/mediatel*\" { pool /CRM/sync/CrmApiMediatel_pool }\n   \"/eservice*\" { pool /CRM/sync/CrmApiEservice_pool }\n   \"/roamingTariffs*\" { pool /CRM/sync/roamingTariffs_pool }\n   \"/oasisNotification*\" { pool /CRM/sync/oasis2crm_pool }\n   \"/oasis2crm/v1/*\" { pool /CRM/sync/oasis2crm_pool }\n   \"/service*\" { pool /CRM/sync/FinTransProcessing_pool }\n   #\"/newsletter/*\" { #pool /CRM/sync/emailrepo_admin_pool }\n   \"/scheduledrechargeshandler/*\" { pool /CRM/sync/scheduledrech_pool }\n   \"/paymentsExecutor/*\" { pool /CRM/sync/paymentsExec_pool }\n   \"/dbfit/*\" { pool /CRM/sync/mfs-dbfit_pool }\n   \"/tkr-executor/*\" { pool /CRM/sync/tkrExecutor_pool }\n   #\"/otapcc*\" { #pool /CRM/sync/otapcc_pool }\n   \"/sso-lolekcj*\" { pool /CRM/sync/lolekcj_logs }\n   \"/sso-lolek*\" { pool /CRM/sync/lolek_logs }\n   \"/otapcc*\" { pool /CRM/sync/otapcc_pool }\n   \"/sso-bolekcj*\" { pool /CRM/sync/bolekcj_logs }\n   \"/sso-bolek*\" { pool /CRM/sync/bolek_logs }\n   \"/akhq/*\" {\n       pool /CRM/sync/akhq_pool \n       }\n   \"/ui*\" {\n       pool /CRM/sync/akhq_pool \n       }\n   \"/dui-admin*\" {\n            pool /CRM/sync/static_nginx_pool\n        }\n   \"/r/admin*\" {\n         HTTP::header replace Host \"url-shortener.rancher-online-dmz.prod.stackstate.intra\"\n         pool /CRM/sync/RancherProd-Online-Internal_pool \n      }\n\n\n   #\"/email-repo*\" { \n   #     pool /CRM/sync/RancherProd-Online-Internal_pool\n        #log local0. \"emailrepo-frontend [IP::client_addr]:  used [HTTP::host] and requested [HTTP::uri] and requesting file [URI::basename [HTTP::path]]\" }\n\n  default { }\n  }\n}\n if { [HTTP::uri] equals \"/Incidente\" } {\n       HTTP::redirect \"http://app.crm.stackstate.intra/Incidente/web/home.jsp\"\n   }\n}"
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_ExchangeSupport_OA_BasicAuth",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_ExchangeSupport_OA_BasicAuth",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_ExchangeSupport_OA_BasicAuth?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    # Global variables\n    # static::POLICY_RESULT_CACHE_AUTHFAILED\n    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.\n    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.\n    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.\n    # Responses\n    # On denied result\n    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.\n    #     In those cases, please use ACCESS::respond command.\n    #     The following is the syntax of ACCESS::respond\n    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]\n    #     e.g. ACCESS::respond 401 content \"Error: Denied\" WWW-Authenticate \"basic realm=\\\"f5.com\\\"\" Connection close\n    when RULE_INIT {\n        # Please set the following global variables for customized responses.\n        set static::actsync_401_http_body \"<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>\"\n        set static::actsync_503_http_body \"<html><title>Service is not available</title><body>Error: Service is not available</body></html>\"\n        set static::ACCESS_LOG_PREFIX                 \"01490000:7:\"\n\n        # Second Virtual Server name for 401 NTLM responder\n        set static::ACCESS_SECOND_VIRTUAL_NAME        \"_ACCESS_401_NTLM_responder_HTTPS\"\n\n        set static::POLICY_INPROGRESS                 \"policy_inprogress\"\n        set static::POLICY_AUTHFAILED                 \"policy_authfailed\"\n        # The request with huge content length can not be used for starting ACCESS session.\n        # This kind of request will be put on hold, and this iRule will try to use another\n        # request to start the session. The following value is used for Outlook Anywhere.\n        set static::OA_MAGIC_CONTENT_LEN              1073741824\n\n        # Similar with OutlookAnywhere case, ACCESS can not use the request which is\n        # larger then following size. This becomes an issue with application that using\n        # Exchange Web Service as its main protocol such as Mac OS X applications\n        # (e.g. Mail app, Microsoft Entourage, etc)\n        # This kind of request will be put on hold, and this iRule will try to use another\n        # request to start the session.\n        set static::FIRST_BIG_POST_CONTENT_LEN        640000\n\n        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.\n        set static::EWS_BKEND_BASIC_AUTH              0\n        # The following variable controls the polling mechanism.\n        set static::POLICY_RESULT_POLL_INTERVAL       250\n        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600\n\n        # Set this global variable to 1 for caching authentication failure\n        # Useful for avoiding account locked out.\n        set static::POLICY_RESULT_CACHE_AUTHFAILED    0\n\n        # set this global variable to set alternative timeout for particular session\n        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120\n\n        set static::ACCESS_USERKEY_TBLNAME            \"_access_userkey\"\n\n\n        set static::ACCESS_DEL_COOKIE_HDR_VAL         \"MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/\"\n\n        log -noname accesscontrol.local1.debug \"01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH\"\n    }\n    when ACCESS_ACL_ALLOWED {\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]\"\n\n        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been\n        # already authenticated if there is a HTTP Basic Auth in the request.\n        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {\n            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header\"\n                HTTP::header remove Authorization\n            }\n        }\n    }\n\n    when HTTP_REQUEST {\n        set http_path                       [ string tolower [HTTP::path] ]\n        set f_clientless_mode               0\n        set f_alt_inactivity_timeout        0\n        set f_rpc_over_http                 0\n        set f_exchange_web_service          0\n        set f_auto_discover                 0\n        set f_activesync                    0\n        set f_offline_address_book          0\n        set f_availability_service          0\n\n        #  Here put appropriate pool when necessary.\n        switch -glob $http_path {\n        \"/rpc/rpcproxy.dll\" {\n            # Supports for RPC over HTTP. (Outlook Anywhere)\n            set f_rpc_over_http 1\n        }\n        \"/autodiscover/autodiscover.xml\" {\n            # Supports for Auto Discover protocol.\n            set f_auto_discover 1\n            # This request does not require long inactivity timeout.\n            # Don't use this for now\n            set f_alt_inactivity_timeout 0\n        }\n        \"/microsoft-server-activesync\" {\n            # Supports for ActiveSync\n            set f_activesync 1\n        }\n        \"/oab/*\" {\n            # Supports for Offline Address Book\n            set f_offline_address_book 1\n            # Don't use this for now\n            set f_alt_inactivity_timeout 0\n        }\n        \"/ews/*\" {\n            # Support for Exchange Web Service\n            # Outlook's Availability Service borrows this protocol.\n            set f_exchange_web_service 1\n        }\n        \"/as/*\" {\n            # Support for Availability Service.\n            # do nothing for now. (Untested)\n            set f_availability_service 1\n        }\n        default {\n            return\n        }\n        }\n\n        set f_reqside_set_sess_id           0\n        set http_method                     [HTTP::method]\n        set http_hdr_host                   [HTTP::host]\n        set http_hdr_uagent                 [HTTP::header User-Agent]\n        set http_uri                        [HTTP::uri]\n        set http_content_len                [HTTP::header Content-Length]\n        set MRHSession_cookie               [HTTP::cookie value MRHSession]\n        set auth_info_b64enc                \"\"\n\n        if { ! [ info exists src_ip ] } {\n            set src_ip                            [IP::remote_addr]\n        }\n        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {\n            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]\n        }\n        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {\n            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]\n        }\n        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {\n            set PROFILE_RESTRICT_SINGLE_IP        1\n        }\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX method: $http_method\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Src IP: $src_ip\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP\"\n\n        # First, do we have valid MRHSession cookie.\n        if { $MRHSession_cookie != \"\" } {\n            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n                set MRHSession_cookie \"\"\n                HTTP::cookie remove MRHSession\n            }\n        }\n\n        set http_hdr_auth [HTTP::header Authorization]\n        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header\"\n            set http_hdr_auth \"\"\n        }\n\n        if { $http_hdr_auth == \"\" } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX No/Empty Auth header\"\n            # clean up the cookie\n            if { $MRHSession_cookie == \"\" } {\n                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate \"Basic realm=\\\"[HTTP::header Host]\\\"\" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close\n                return\n            }\n            # Do nothing if we have a valid MRHSession cookie.\n        }\n\n        set f_release_request           0\n        # Optimization for clients which support cookie\n        if { $MRHSession_cookie != \"\" } {\n            # Default profile access setting is false\n            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                set f_release_request 1\n            }\n            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie \"session.user.clientip\" ] ] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP matched\"\n                set f_release_request 1\n            }\n            else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP does not matched\"\n                set MRHSession_cookie \"\"\n                HTTP::cookie remove MRHSession\n            }\n        }\n\n        if { $f_release_request == 0 } {\n            set apm_username [string tolower [HTTP::username]]\n            set apm_password [HTTP::password]\n            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                binary scan [md5 \"$apm_password\"] H* user_hash\n            }\n            else {\n                binary scan [md5 \"$apm_password$src_ip\"] H* user_hash\n            }\n            set user_key    \"$apm_username.$user_hash\"\n            unset user_hash\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX apm_username: $apm_username\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX user_key = $user_key\"\n            set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n            if { [ llength $apm_cookie_list ] != 0 } {\n                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n                if { $apm_cookie != \"\" } {\n                    HTTP::cookie insert name MRHSession value $apm_cookie\n                    set f_release_request 1\n                }\n            }\n        }\n\n        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {\n            set f_oa_magic_content_len 1\n        }\n\n        set f_sleep_here 0\n        set retry 1\n\n        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len\"\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME\"\n\n            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]\n            if { $apm_cookie != \"\" } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie\"\n\n                # Accessing SessionDB is not that cheap. Here we are trying to check known value.\n                if { $apm_cookie == \"policy_authfailed\" || $apm_cookie == \"policy_inprogress\"} {\n                    # Do nothing\n                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync\"\n                    # Table value is out of sync. Ignores it.\n                    set apm_cookie \"\"\n                }\n            }\n\n            switch $apm_cookie {\n            \"\" {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX NO APM Cookie found\"\n\n                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {\n                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable\n                    # for creating new session since 1G content-length is intended for client to upload\n                    # the data when needed.\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len\"\n                    set f_sleep_here 1\n                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {\n                    # Here we are getting large EWS request, which can't be used for starting new session\n                    # in clientless-mode. Have it here waiting for next smaller one.\n                    # We are holding the request here in HTTP filter, and HTTP filter automatically\n                    # clamping down the TCP window when necessary.\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request\"\n                    set f_sleep_here 1\n                } else {\n                   set apm_cookie               \"policy_inprogress\"\n                   set f_reqside_set_sess_id    1\n                   set f_release_request        1\n                }\n            }\n            \"policy_authfailed\" {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED\"\n                HTTP::respond 401 content  $static::actsync_401_http_body\n                set f_release_request 1\n            }\n            \"policy_inprogress\" {\n                if { [ info exists f_activesync ] && ($f_activesync == 1) } {\n                    # For ActiveSync requests, aggressively starts new session.\n                    set f_reqside_set_sess_id    1\n                    set f_release_request        1\n                } else {\n                    set f_sleep_here 1\n                }\n            }\n            default {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie\"\n                HTTP::header insert Cookie \"MRHSession=$apm_cookie\"\n                set f_release_request 1\n            }\n            }\n\n            if { $f_reqside_set_sess_id == 1 } {\n                set f_reqside_set_sess_id 0\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT\"\n                set f_clientless_mode 1\n                HTTP::cookie remove MRHSession\n                HTTP::header insert \"clientless-mode\" 1\n                HTTP::header insert \"username\" $apm_username\n                HTTP::header insert \"password\" $apm_password\n                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT\n            }\n\n            if { $f_sleep_here == 1 } {\n                set f_sleep_here 0\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri\"\n                after  $static::POLICY_RESULT_POLL_INTERVAL\n            }\n\n            incr retry\n        }\n\n        if { ($f_release_request == 0) && ($retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE) } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri\"\n\n            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n            ACCESS::disable\n            TCP::close\n            return\n        }\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri\"\n    }\n\n    when ACCESS_SESSION_STARTED {\n        if { [ info exists user_key ] } {\n\n            ACCESS::session data set \"session.user.uuid\" $user_key\n            ACCESS::session data set \"session.user.microsoft-exchange-client\" 1\n\n            if { [ info exists f_activesync ] && $f_activesync == 1 } {\n                ACCESS::session data set \"session.user.microsoft-activesync\" 1\n            }\n            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {\n                ACCESS::session data set \"session.user.microsoft-autodiscover\" 1\n            }\n            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {\n                ACCESS::session data set \"session.user.microsoft-availabilityservice\" 1\n            }\n            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {\n                ACCESS::session data set \"session.user.microsoft-rpcoverhttp\" 1\n            }\n            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {\n                ACCESS::session data set \"session.user.microsoft-offlineaddressbook\" 1\n            }\n            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {\n                ACCESS::session data set \"session.user.microsoft-exchangewebservice\" 1\n            }\n        }\n        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {\n            ACCESS::session data set \"session.inactivity_timeout\"  $static::POLICY_ALT_INACTIVITY_TIMEOUT\n        }\n    }\n\n    when ACCESS_POLICY_COMPLETED {\n        if { ! [ info exists user_key ] } {\n            return\n        }\n\n        set user_key_value \"\"\n        set f_delete_session 0\n        set policy_result [ACCESS::policy result]\n        set sid [ ACCESS::session sid ]\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \\\"$policy_result\\\" user_key = \\\"$user_key\\\" sid = \\\"$sid\\\"\"\n\n        set inactivity_timeout [ACCESS::session data get \"session.inactivity_timeout\"]\n        set max_sess_timeout [ACCESS::session data get \"session.max_session_timeout\"]\n        if { $max_sess_timeout == \"\" } {\n             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT\n        }\n\n        switch $policy_result {\n        \"allow\" {\n            # We depends on this table record self-cleanup capability in order to\n            # indirectly sync with session DB.\n            set user_key_value $sid\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX sid = $sid\"\n        }\n        \"deny\" {\n            # When necessary the admin here can check appropriate session variable\n            # and decide what response more appropriate then this default response.\n            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close\n            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {\n                set user_key_value  $static::POLICY_AUTHFAILED\n            } else {\n                set f_delete_session  1\n            }\n        }\n        default {\n            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)\"\n            set f_delete_session  1\n        }\n        }\n        if { $user_key_value != \"\" } {\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME\"\n\n           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout\n        } else {\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME\"\n\n           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n        }\n\n        if { $f_delete_session == 1 } {\n           ACCESS::session remove\n           set f_delete_session 0\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Removing the session for $user_key.\"\n        }\n    }\ndefinition-signature H5CYoxBTBYqkK6ZFPeoX68vIv3V9TsbZCwIutNCnPovGN2T8TFPGOUqCX2RL7RhG2y5AAUMPDAat8KDHfy2hQpzENUuW1f0ZmrBg5SCeJdo5FINqqHgwydriQx14njq+FPYTgRYo/j9NxyNzeN9LsiYt6fccBOSzpXqXTfkU0D0ES6QfCsNNoDAsFRBBu9FDT+TjHOz8d2XqRlUZQ/bosGp8NPgU5hGlHkaPbq0tZS90DqmX+CNBcipQHohaJYipyfEryYvHVkC6qet0yKq3jjq0X7CgG3g3WTbXI7U+CMvCb3j1jJlCwdn7b1KWd/ghdKVPgmzTdx+GIoWWLGhelQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_ExchangeSupport_OA_NtlmAuth",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_ExchangeSupport_OA_NtlmAuth",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_ExchangeSupport_OA_NtlmAuth?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when RULE_INIT {\n        set static::POLICY_INPROGRESS                 \"policy_inprogress\"\n        set static::POLICY_FAILED                     \"policy_failed\"\n        set static::POLICY_SUCCEED                    \"policy_succeed\"\n        set static::POLICY_DONE_WAIT_SEC              5\n\n        set static::FIRST_BIG_POST_CONTENT_LEN        640000\n        set static::POLICY_RESULT_POLL_INTERVAL       100\n        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  100\n        set static::ACCESS_USERKEY_TBLNAME            \"_access_userkey\"\n        set static::ACCESS_LOG_PREFIX                 \"01490000:7:\"\n\n        set static::USE_NTLM_AUTH                     0\n        set static::USE_BASIC_AUTH                    1\n        set static::USE_NTLM_BASIC_AUTH               2\n\n        set static::URL_DEFAULT                       0\n        set static::URL_RPC_OVER_HTTP                 1\n        set static::URL_AUTODISCOVER                  2\n        set static::URL_ACTIVE_SYNC                   3\n        set static::URL_OFFLINEADDRESSBOOK            4\n        set static::URL_EXCHANGEWEBSERVICE            5\n\n        set static::RECVD_AUTH_NONE                   0\n        set static::RECVD_AUTH_NTLM                   1\n        set static::RECVD_AUTH_BASIC                  2\n\n        set static::ACCESS_DEL_COOKIE_HDR_VAL         \"MRHSession=deleted; \\\n                                                       expires=Thu, 01-Jan-1970 00:00:01 GMT;\\\n                                                       path=/\"\n\n    }\n\n    when HTTP_REQUEST {\n        set http_path                       [string tolower [HTTP::path]]\n        set url_path                        $static::URL_DEFAULT\n        set use_auth                        $static::USE_NTLM_AUTH\n        set f_disable_sso                   0\n\n        switch -glob $http_path {\n        \"/rpc/rpcproxy.dll\" {\n            set url_path                    $static::URL_RPC_OVER_HTTP\n        }\n        \"/autodiscover/autodiscover.xml\" {\n            set url_path                    $static::URL_ACTIVE_SYNC\n            # Need to support both NTLM and Basic authentication for this URL\n            set use_auth                    $static::USE_NTLM_BASIC_AUTH\n        }\n        \"/microsoft-server-activesync*\" {\n            set url_path                    $static::URL_ACTIVE_SYNC\n            # Use only Basic authentication for this URL\n            set use_auth                    $static::USE_BASIC_AUTH\n            set f_disable_sso               1\n        }\n        \"/oab*\" {\n            set url_path                    $static::URL_OFFLINEADDRESSBOOK\n        }\n        \"/ews*\" {\n            set url_path                    $static::URL_EXCHANGEWEBSERVICE\n        }\n        default {\n            ECA::disable\n            return\n        }\n        }\n\n        if { ! [ info exists f_ntlm_auth_succeed ] } {\n            set f_ntlm_auth_succeed         0\n        }\n        if { ! [ info exists sid_cache ] } {\n            set sid_cache                         \"\"\n        }\n        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { \n            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]\n        }\n        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {\n            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]\n        }\n        if { ! [ info exists src_ip ] } {\n            set src_ip                            [IP::remote_addr]\n        }\n        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {\n            set PROFILE_RESTRICT_SINGLE_IP        1\n        }\n\n        set http_method                     [HTTP::method]\n        set http_hdr_host                   [HTTP::host]\n        set http_hdr_uagent                 [HTTP::header User-Agent]\n        set http_uri                        [HTTP::uri]\n        set http_content_len                [HTTP::header Content-Length]\n        set MRHSession_cookie               [HTTP::cookie value MRHSession]\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX method:      $http_method\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Src IP:      $src_ip\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX User-Agent:  $http_hdr_uagent\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP uri:    $http_uri\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP len:    $http_content_len\"\n\n        if { ! [ info exists ECA_METADATA_ARG ] } {\n            # Generating argument for ECA::metadata\n            # The NTLM configuration name is derived from assigned virtual name with the algorithm as follows:\n            # <virtual-fullpath> ::= <folder-path>\"/\"<virtual-basename> as \"/\" is the last \"/\" char.\n            # <config-fullpath>  ::= <folder-path>\"/\" \"exch_ntlm\" \"_\" <virtual-basename>\n            # e.g.  Let us say the virtual name is \"/prod/exch/vs1\", The folder path is \"/prod/exch/\",\n            #       then object name will be \"/prod/exch/exch_ntlm_vs1\".\n            set vs_name [virtual name]\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX virtual:     $vs_name\"\n            set slash_index [ string last / $vs_name ]\n            if { $slash_index == -1 } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Error: the virtual name does not contain folder information\"\n                ACCESS::disable\n                TCP::close\n                return\n            }\n            set ECA_METADATA_ARG    \"select_ntlm:\"\n            append ECA_METADATA_ARG [ string range $vs_name 0 $slash_index ]\n            append ECA_METADATA_ARG \"exch_ntlm_\"\n            append ECA_METADATA_ARG [ string range $vs_name [ expr { $slash_index + 1 } ] end ]\n            unset slash_index\n            unset vs_name\n        }\n\n        if { $use_auth == $static::USE_NTLM_AUTH } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG\"\n            ECA::enable\n            ECA::select $ECA_METADATA_ARG\n            return\n        } else {\n            set recvd_auth                      $static::RECVD_AUTH_NONE\n            set http_hdr_auth                   [HTTP::header Authorization]\n            set auth_data                       [split $http_hdr_auth \" \"]\n            if { $http_hdr_auth != \"\" } {\n                if { [ llength $auth_data ] == 2 } {\n                    set auth_scheme [ lindex $auth_data 0]\n                    if { [string equal -nocase $auth_scheme \"ntlm\" ] == 1 } {\n                        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Recv'd HTTP NTLM Authentication\"\n                        set recvd_auth          $static::RECVD_AUTH_NTLM\n                    } elseif { [ string equal -nocase [ lindex $auth_data 0] \"basic\" ] == 1 } {\n                        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Recv'd HTTP Basic Authentication\"\n                        set recvd_auth          $static::RECVD_AUTH_BASIC\n                        set user                [string tolower [HTTP::username]]\n                        set password            [HTTP::password]\n                    }\n                }\n            }\n            if { $use_auth == $static::USE_BASIC_AUTH } {\n                if { $recvd_auth == $static::RECVD_AUTH_BASIC } {\n                    # Defer the process until later\n                } else {\n                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate \"Basic realm=\\\"$http_hdr_host\\\"\" \\\n                                Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close\n                    return\n                }\n            } elseif { $use_auth == $static::USE_NTLM_BASIC_AUTH } {\n                if { ($recvd_auth == $static::RECVD_AUTH_NTLM) || ($f_ntlm_auth_succeed == 1) } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG\"\n                    ECA::enable\n                    ECA::select $ECA_METADATA_ARG\n                    return\n                } elseif { $recvd_auth == $static::RECVD_AUTH_BASIC } {\n                    # Defer the process until later\n                } else {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Request Authorization: NTLM + Basic\"\n                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate \"Basic realm=\\\"$http_hdr_host\\\"\" \\\n                                WWW-Authenticate \"NTLM\" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close\n                    return\n                }\n            }\n\n            # Disable NTLM auth\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Disable ECA\"\n            ECA::disable\n            # Disable KCD sso\n            set f_disable_sso               1\n\n            if { $MRHSession_cookie != \"\" } {\n                if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n                    # Default profile access setting is false\n                    if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Release the request\"\n                        return\n                    }\n                    elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie \"session.user.clientip\" ] ] } {\n                        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP matched. Release the request\"\n                        return\n                    }\n                    else {\n                        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP does not matched\"\n                    }\n                }\n                else {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n                }\n\n                set MRHSession_cookie \"\"\n                HTTP::cookie remove MRHSession\n            }\n\n            set user_key                {}\n            if { $PROFILE_RESTRICT_SINGLE_IP == 1 } {\n                append user_key                    $src_ip\n            }\n            append user_key                 $password\n            binary scan [md5 $user_key ] H* user_key\n            set user_key                    \"$user.$user_key\"\n\n            set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n            if { [ llength $apm_cookie_list ] != 0 } {\n                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n                if { $MRHSession_cookie != \"\" } {\n                    HTTP::cookie remove MRHSession \n                    HTTP::cookie insert name MRHSession value $MRHSession_cookie\n                    return\n                }\n            }\n\n            HTTP::cookie remove MRHSession\n            HTTP::header insert \"clientless-mode\"       1\n            HTTP::header insert \"username\"              $user\n            HTTP::header insert \"password\"              $password\n            return\n        }\n    }\n\n    when ECA_REQUEST_ALLOWED {\n        set f_ntlm_auth_succeed                 1\n\n        if { $MRHSession_cookie == \"\" } {\n            # Retrieve from SID cache\n            set MRHSession_cookie   $sid_cache\n            HTTP::cookie insert name MRHSession value $sid_cache\n        }\n\n        if { $MRHSession_cookie != \"\" } {\n            # Destroy session ID cache. This client should not need session ID cache \n            if { ($sid_cache != \"\") && ($sid_cache != $MRHSession_cookie) } {\n                set sid_cache   \"\"\n            }\n            if { [ ACCESS::session exists -state_allow $MRHSession_cookie ] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n                # Default profile access setting is false\n                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Release the request\"\n                    return\n                }\n                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie \"session.user.clientip\" ] ] } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP matched. Release the request\"\n                    return\n                }\n                else {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP does not matched\"\n                }\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n            }\n        }\n\n        set MRHSession  \"\"\n        set sid_cache   \"\"\n        HTTP::cookie remove MRHSession\n\n        # Build user_key\n        set    user_key                 {}\n        append user_key                 [string tolower [ECA::username]] \"@\" [ string tolower [ECA::domainname] ]\n        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n            append user_key             \":\" $src_ip\n        }\n        append user_key                 \":\" [ECA::client_machine_name]\n\n        set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n        if { [ llength $apm_cookie_list ] != 0 } {\n            set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n            if { $MRHSession_cookie != \"\" } {\n                set sid_cache           $MRHSession_cookie\n                HTTP::cookie insert name MRHSession value $MRHSession_cookie\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache\"\n                return\n            }\n        }\n        unset apm_cookie_list\n\n        set try                         1\n        set start_policy_str            $src_ip\n        append start_policy_str         [TCP::client_port]\n\n        while { $try <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX NO APM Cookie found\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Trying #$try for $http_method $http_uri $http_content_len\"\n\n            if { $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {\n                # Wait at below\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX EXEC: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT\"\n                set policy_status [table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT]\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX DONE: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT\"\n                if { $policy_status == $start_policy_str } {\n                    # ACCESS Policy has not started. Start one\n                    HTTP::header insert \"clientless-mode\"    1\n                    break\n                } elseif { $policy_status == $static::POLICY_SUCCEED } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX table is out-of-sync retry\"\n                    table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n                    continue\n                } elseif { $policy_status == $static::POLICY_FAILED } {\n                    ACCESS::disable\n                    TCP::close\n                    return\n                }\n                # Wait at below\n            }\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri\"\n            # Touch the entry table\n            table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n            after  $static::POLICY_RESULT_POLL_INTERVAL\n\n            set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n            if { [ llength $apm_cookie_list ] != 0 } {\n                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n                if { $MRHSession_cookie != \"\" } {\n                    set sid_cache           $MRHSession_cookie\n                    HTTP::cookie insert name MRHSession value $MRHSession_cookie\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache\"\n                    return\n                }\n            }\n\n            incr try\n        }\n\n        if { $try >  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Policy did not finish in [ expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri\"\n            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n            ACCESS::disable\n            TCP::close\n            return\n        }\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri\"\n\n        unset try\n        unset start_policy_str\n    }\n\n    when ECA_REQUEST_DENIED {\n        set f_ntlm_auth_succeed                 0\n    }\n\n    when HTTP_RESPONSE_RELEASE {\n        if { ! [info exists user_key] } {\n            return\n        }\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP response: status:           [HTTP::status]\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP response: Server:           [HTTP::header Server]\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP response: Content-Length:   [HTTP::header Content-Length]\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP response: WWW-Authenticate: [HTTP::header WWW-Authenticate]\"\n    }\n\n    when ACCESS_SESSION_STARTED {\n        if { [ info exists user_key ] } {\n            ACCESS::session data set \"session.user.uuid\" $user_key\n            ACCESS::session data set \"session.user.microsoft-exchange-client\" 1\n        }\n    }\n\n    when ACCESS_ACL_ALLOWED {\n        if { [ info exists f_disable_sso ] && $f_disable_sso == 1 } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Disable WEBSSO\"\n            WEBSSO::disable\n        }\n    }\n\n    when ACCESS_POLICY_COMPLETED {\n        if { ! [ info exists user_key ] } {\n            return\n        }\n\n        set user_key_value \"\"\n        set f_delete_session 0\n        set policy_result [ACCESS::policy result]\n        set sid [ ACCESS::session sid ]\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \\\"$policy_result\\\" user_key = \\\"$user_key\\\" sid = \\\"$sid\\\"\"\n\n        switch $policy_result {\n        \"allow\" {\n            set user_key_value          $sid\n            set sid_cache               $user_key_value\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Result: Allow: $user_key\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX sid = $sid\"\n\n        }\n        \"deny\" {\n            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close\n            set f_delete_session  1\n        }\n        default {\n            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)\"\n            set f_delete_session  1\n        }\n        }\n\n        if { $f_ntlm_auth_succeed == 1 } {\n            if { $user_key_value != \"\" } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_SUCCEED\"\n                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_SUCCEED\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC_in table $static::ACCESS_USERKEY_TBLNAME\"\n                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC\n            }\n        }\n\n        if { $f_delete_session == 1 } {\n            ACCESS::session remove\n            set f_delete_session 0\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Removing the session for $user_key.\"\n        }\n    }\ndefinition-signature r8S3kABK0vdxA0Gp40e6xD2LQblbxGAkRljfRv6aqqEPI7CzHdLHa6Own6/2+ao+rqYecm5mqNGUr2StMN1FwrTp8grRVhJFy4G3UmIYm8EGsHQWkQ+4UClXNHJsJYIBEBY0BaLtcf47O46Hsixv51FcdBTsAGmHjttSs2m5iOPXp/vgCY4CgqzCHMHshNLqX23c1y2iehSqpBm9K1YgQIFE0jpIA/k6LcELD0Ck13mTtVSrMWZjelrwTWj2o0FzAfHVDoQRtGzVZDC5bdYgpzeY75vFvx16wUbIy2eGJXHnkvf6D7Mggk5PyZ4UguoQtdiPJhNQU18X9lBDl6xZFQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_ExchangeSupport_helper",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_ExchangeSupport_helper",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_ExchangeSupport_helper?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    # The purpose of this iRule is for help the main virtual for the timing of the HTTP request retry\n    # during the SSO process for OutlookAnywhere protocol request which has a Content-Length value of 1GB.\n\n    when HTTP_REQUEST {\n        #  Waiting for the first chunk of data.\n        HTTP::collect 1\n    }\n\n    when HTTP_REQUEST_DATA {\n        # Respond 401 and close the connection once we received the data.\n        HTTP::respond 401 WWW-Authenticate NTLM Connection close\n    }\ndefinition-signature nR01gptC7P7Tejd6mkHebwHVheXTs9v1yM1Ne0A26dTNbUAu5a/Hw3qngZnmPaHBvPMBMgb1+qm0jogFZ7c2P93pPTfxRWWlpzHJfVhkhxLkCeaqvlKECt9Q0xihCZFu+fTivkNwnqdKTq0HKpnXWv3Z+l0nq5UqOtDNnSJ4qu2ZKGEoBfL7wtc+kOEgQLBSdoYgn8ed2QpScVOuwJjK0HlS6MxLxOBZaHx0Yi7xfmU/G+CDOMD4pCUN9noS8uB+BWHG2Irj7EKdxZUgUlGlVDICKpkr+JHzCPDZ0uTqHU0PmzbIgefKSzS2GR4DkgaeVb3TTwXne/tYfWDIOrvxiw==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_ExchangeSupport_main",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_ExchangeSupport_main",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_ExchangeSupport_main?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    # Global variables\n    # static::POLICY_RESULT_CACHE_AUTHFAILED\n    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.\n    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.\n    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.\n    # Responses\n    # On denied result\n    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.\n    #     In those cases, please use ACCESS::respond command.\n    #     The following is the syntax of ACCESS::respond\n    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]\n    #     e.g. ACCESS::respond 401 content \"Error: Denied\" WWW-Authenticate \"basic realm=\\\"f5.com\\\"\" Connection close\n    when RULE_INIT {\n        # Please set the following global variables for customized responses.\n        set static::actsync_401_http_body \"<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>\"\n        set static::actsync_503_http_body \"<html><title>Service is not available</title><body>Error: Service is not available</body></html>\"\n        set static::ACCESS_LOG_PREFIX                 \"01490000:7:\"\n\n        # Second Virtual Server name for 401 NTLM responder\n        set static::ACCESS_SECOND_VIRTUAL_NAME        \"_ACCESS_401_NTLM_responder_HTTPS\"\n\n        set static::POLICY_INPROGRESS                 \"policy_inprogress\"\n        set static::POLICY_AUTHFAILED                 \"policy_authfailed\"\n        # The request with huge content length can not be used for starting ACCESS session.\n        # This kind of request will be put on hold, and this iRule will try to use another\n        # request to start the session. The following value is used for Outlook Anywhere.\n        set static::OA_MAGIC_CONTENT_LEN              1073741824\n\n        # Similar with OutlookAnywhere case, ACCESS can not use the request which is\n        # larger then following size. This becomes an issue with application that using\n        # Exchange Web Service as its main protocol such as Mac OS X applications\n        # (e.g. Mail app, Microsoft Entourage, etc)\n        # This kind of request will be put on hold, and this iRule will try to use another\n        # request to start the session.\n        set static::FIRST_BIG_POST_CONTENT_LEN        640000\n\n        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.\n        set static::EWS_BKEND_BASIC_AUTH              0\n        # Set it into 1 if the backend RPC-over-HTTP handler accepts HTTP Basic Authentication.\n        set static::RPC_OVER_HTTP_BKEND_BASIC_AUTH    0\n        # The following variable controls the polling mechanism.\n        set static::POLICY_RESULT_POLL_INTERVAL       250\n        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600\n\n        # Set this global variable to 1 for caching authentication failure\n        # Useful for avoiding account locked out.\n        set static::POLICY_RESULT_CACHE_AUTHFAILED    0\n\n        # set this global variable to set alternative timeout for particular session\n        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120\n\n        set static::ACCESS_USERKEY_TBLNAME            \"_access_userkey\"\n\n\n        set static::ACCESS_DEL_COOKIE_HDR_VAL         \"MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/\"\n\n        log -noname accesscontrol.local1.debug \"01490000:7: RPC_OVER_HTTP_BKEND_BASIC_AUTH = $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH\"\n        log -noname accesscontrol.local1.debug \"01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH\"\n    }\n    when ACCESS_ACL_ALLOWED {\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]\"\n\n        if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 }  {\n            if { $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH == 0 } {\n                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Use this virtual $static::ACCESS_SECOND_VIRTUAL_NAME just once. Will be reset back after disconnection.\"\n                    use virtual $static::ACCESS_SECOND_VIRTUAL_NAME\n                }\n               log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Remove HTTP Auth header\"\n               HTTP::header remove Authorization\n            }\n        }\n        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been\n        # already authenticated if there is a HTTP Basic Auth in the request.\n        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {\n            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header\"\n                HTTP::header remove Authorization\n            }\n        }\n    }\n\n    when HTTP_REQUEST {\n        set http_path                       [ string tolower [HTTP::path] ]\n        set f_clientless_mode               0\n        set f_alt_inactivity_timeout        0\n        set f_rpc_over_http                 0\n        set f_exchange_web_service          0\n        set f_auto_discover                 0\n        set f_activesync                    0\n        set f_offline_address_book          0\n        set f_availability_service          0\n\n        #  Here put appropriate pool when necessary.\n        switch -glob $http_path {\n        \"/rpc/rpcproxy.dll\" {\n            # Supports for RPC over HTTP. (Outlook Anywhere)\n            set f_rpc_over_http 1\n        }\n        \"/autodiscover/autodiscover.xml\" {\n            # Supports for Auto Discover protocol.\n            set f_auto_discover 1\n            # This request does not require long inactivity timeout.\n            # Don't use this for now\n            set f_alt_inactivity_timeout 0\n        }\n        \"/microsoft-server-activesync\" {\n            # Supports for ActiveSync\n            set f_activesync 1\n        }\n        \"/oab/*\" {\n            # Supports for Offline Address Book\n            set f_offline_address_book 1\n        }\n        \"/ews/*\" {\n            # Support for Exchange Web Service\n            # Outlook's Availability Service borrows this protocol.\n            set f_exchange_web_service 1\n        }\n        \"/as/*\" {\n            # Support for Availability Service.\n            # do nothing for now. (Untested)\n            set f_availability_service 1\n        }\n        default {\n            return\n        }\n        }\n\n        set f_reqside_set_sess_id           0\n        set http_method                     [HTTP::method]\n        set http_hdr_host                   [HTTP::host]\n        set http_hdr_uagent                 [HTTP::header User-Agent]\n        set src_ip                          [IP::remote_addr]\n        set http_uri                        [HTTP::uri]\n        set http_content_len                [HTTP::header Content-Length]\n        set MRHSession_cookie               [HTTP::cookie value MRHSession]\n        set auth_info_b64enc                \"\"\n\n        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {\n            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]\n        }\n        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {\n            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]\n        }\n        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {\n            set PROFILE_RESTRICT_SINGLE_IP        1\n        }\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX method: $http_method\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Src IP: $src_ip\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len\"\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP\"\n\n        # First, do we have valid MRHSession cookie.\n        if { $MRHSession_cookie != \"\" } {\n            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n                set MRHSession_cookie \"\"\n                HTTP::cookie remove MRHSession\n            }\n        }\n\n        set http_hdr_auth [HTTP::header Authorization]\n        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header\"\n            set http_hdr_auth \"\"\n        }\n\n        if { $http_hdr_auth == \"\" } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX No/Empty Auth header\"\n            # clean up the cookie\n            if { $MRHSession_cookie == \"\" } {\n                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate \"Basic realm=\\\"[HTTP::header Host]\\\"\" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close\n                return\n            }\n            # Do nothing if we have a valid MRHSession cookie.\n        }\n\n        set f_release_request           0\n        # Optimization for clients which support cookie\n        if { $MRHSession_cookie != \"\" } {\n            # Default profile access setting is false\n            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                set f_release_request 1\n            }\n            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie \"session.user.clientip\" ] ] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP matched\"\n                set f_release_request 1\n            }\n            else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP does not matched\"\n                set MRHSession_cookie \"\"\n                HTTP::cookie remove MRHSession\n            }\n        }\n\n        if { $f_release_request == 0 } {\n            set apm_username [ string tolower [HTTP::username]]\n            set apm_password [HTTP::password]\n            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                binary scan [md5 \"$apm_password\"] H* user_hash\n            } else {\n                binary scan [md5 \"$apm_password$src_ip\"] H* user_hash\n            }\n\n            set user_key    {}\n            append user_key $apm_username \".\" $user_hash\n            unset user_hash\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX apm_username: $apm_username\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX user_key = $user_key\"\n            set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n            if { [ llength $apm_cookie_list ] != 0 } {\n                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n                if { $apm_cookie != \"\" } {\n                    HTTP::cookie insert name MRHSession value $apm_cookie\n                    set f_release_request 1\n                }\n            }\n        }\n\n        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {\n            set f_oa_magic_content_len 1\n        }\n\n        set f_sleep_here 0\n        set retry 1\n\n        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len\"\n\n            # This is also going to touch the table entry timer.\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME\"\n\n            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]\n            if { $apm_cookie != \"\" } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie\"\n\n                # Accessing SessionDB is not that cheap. Here we are trying to check known value.\n                if { $apm_cookie == \"policy_authfailed\" || $apm_cookie == \"policy_inprogress\"} {\n                    # Do nothing\n                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync\"\n                    # Table value is out of sync. Ignores it.\n                    set apm_cookie \"\"\n                }\n            }\n\n            switch $apm_cookie {\n            \"\" {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX NO APM Cookie found\"\n\n                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {\n                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable\n                    # for creating new session since 1G content-length is intended for client to upload\n                    # the data when needed.\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len\"\n                    set f_sleep_here 1\n                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {\n                    # Here we are getting large EWS request, which can't be used for starting new session\n                    # in clientless-mode. Have it here waiting for next smaller one.\n                    # We are holding the request here in HTTP filter, and HTTP filter automatically\n                    # clamping down the TCP window when necessary.\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request\"\n                    set f_sleep_here 1\n                } else {\n                   set apm_cookie               \"policy_inprogress\"\n                   set f_reqside_set_sess_id    1\n                   set f_release_request        1\n                }\n            }\n            \"policy_authfailed\" {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED\"\n                HTTP::respond 401 content  $static::actsync_401_http_body\n                set f_release_request 1\n            }\n            \"policy_inprogress\" {\n                if { [ info exists f_activesync ] && ($f_activesync == 1) } {\n                    # For ActiveSync requests, aggressively starts new session.\n                    set f_reqside_set_sess_id    1\n                    set f_release_request        1\n                } else {\n                    set f_sleep_here 1\n                }\n            }\n            default {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie\"\n                HTTP::header insert Cookie \"MRHSession=$apm_cookie\"\n                set f_release_request 1\n            }\n            }\n\n            if { $f_reqside_set_sess_id == 1 } {\n                set f_reqside_set_sess_id 0\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT\"\n                set f_clientless_mode 1\n                HTTP::cookie remove MRHSession\n                HTTP::header insert \"clientless-mode\" 1\n                HTTP::header insert \"username\" $apm_username\n                HTTP::header insert \"password\" $apm_password\n                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT\n            }\n\n            if { $f_sleep_here == 1 } {\n                set f_sleep_here 0\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri\"\n                after  $static::POLICY_RESULT_POLL_INTERVAL\n            }\n\n            incr retry\n        }\n\n        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri\"\n\n            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n            ACCESS::disable\n            TCP::close\n            return\n        }\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri\"\n    }\n\n    when ACCESS_SESSION_STARTED {\n        if { [ info exists user_key ] } {\n            ACCESS::session data set \"session.user.uuid\" $user_key\n            ACCESS::session data set \"session.user.microsoft-exchange-client\" 1\n\n            if { [ info exists f_activesync ] && $f_activesync == 1 } {\n                ACCESS::session data set \"session.user.microsoft-activesync\" 1\n            }\n            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {\n                ACCESS::session data set \"session.user.microsoft-autodiscover\" 1\n            }\n            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {\n                ACCESS::session data set \"session.user.microsoft-availabilityservice\" 1\n            }\n            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {\n                ACCESS::session data set \"session.user.microsoft-rpcoverhttp\" 1\n            }\n            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {\n                ACCESS::session data set \"session.user.microsoft-offlineaddressbook\" 1\n            }\n            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {\n                ACCESS::session data set \"session.user.microsoft-exchangewebservice\" 1\n            }\n        }\n        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {\n            ACCESS::session data set \"session.inactivity_timeout\"  $static::POLICY_ALT_INACTIVITY_TIMEOUT\n        }\n    }\n\n    when HTTP_RESPONSE {\n        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {\n            set content_len [ HTTP::header Content-Length ]\n            if {  $content_len > 0 } {\n                HTTP::collect $content_len\n            }\n        }\n    }\n    when HTTP_RESPONSE_DATA {\n        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {\n            if { [ regsub -line {<AuthPackage>Ntlm</AuthPackage>} [ HTTP::payload ] {<AuthPackage>Basic</AuthPackage>} payload ] != 0 } {\n                HTTP::payload replace 0 $content_len $payload\n            }\n        }\n    }\n    when ACCESS_POLICY_COMPLETED {\n        if { ! [ info exists user_key ] } {\n            return\n        }\n\n        set user_key_value \"\"\n        set f_delete_session 0\n        set policy_result [ACCESS::policy result]\n        set sid [ ACCESS::session sid ]\n\n        log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \\\"$policy_result\\\" user_key = \\\"$user_key\\\" sid = \\\"$sid\\\"\"\n\n        set inactivity_timeout [ACCESS::session data get \"session.inactivity_timeout\"]\n        set max_sess_timeout [ACCESS::session data get \"session.max_session_timeout\"]\n        if { $max_sess_timeout == \"\" } {\n             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT\n        }\n\n        switch $policy_result {\n        \"allow\" {\n            # We depends on this table record self-cleanup capability in order to\n            # indirectly sync with session DB.\n            set user_key_value $sid\n\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value\"\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX sid = $sid\"\n        }\n        \"deny\" {\n            # When necessary the admin here can check appropriate session variable\n            # and decide what response more appropriate then this default response.\n            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close\n            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {\n                set user_key_value  $static::POLICY_AUTHFAILED\n            } else {\n                set f_delete_session  1\n            }\n        }\n        default {\n            ACCESS::respond 503 content  $static::actsync_503_http_body Connection close\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)\"\n            set f_delete_session  1\n        }\n        }\n        if { $user_key_value != \"\" } {\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME\"\n\n           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout\n        } else {\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME\"\n\n           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key\n        }\n\n        if { $f_delete_session == 1 } {\n           ACCESS::session remove\n           set f_delete_session 0\n           log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Removing the session for $user_key.\"\n        }\n    }\ndefinition-signature ask7ZvjsIV6uvTW96hX6vOlEEBZlb/9PE7FJRiglRmIc+UP3Cb7188DVUorFFTbpGTM/gLe2Qj2OxMP6IEYjNVwJQuD2pQ6Q4lk+dILO5jbTwn2zfuauMIXcO8HpiYow08vQaddT/CxYEsWJwzaakuRgyoJGt/bbeC1u3RdHn4de+3BVBqTMMajKXKzvn13mqH1B/WTs/Z2+ZHw74bKVJ66VXd29tKvD8NQMZGo4oAj2HtCakbxU9b2Tksch4Wmc9RXXiS53cUbk0TK+ZMG3otsUgJnim3BYFqQkBQLxqiChwN5N1Fcp95KOeunJ0qcZDTwuKV4CoRcfMovU0aUOog==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_MS_Office_OFBA_Support",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_MS_Office_OFBA_Support",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_MS_Office_OFBA_Support?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012, 2016-2017, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n# Supporting MS-OFBA protocol for native office applications.\n# sys_APM_MS_Office_OFBA_DG - iRule data group to customize ofba user agent strings and\n#                     few other parameters.\n#\n# sys_APM_MS_Office_OFBA_DG::useragent - useragent strings are mandatory, \n#       these strings are used to detect OFBA clients. All user agent strings should start\n#       with useragent name, for e.g: useragent1, useragent2.. etc.\n#\n# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_enabled - Parameter to specify whether to enable or\n#       disable IE session sharing using persistent cookie named \"MRHSOffice\".\n#       Default is disabled (0), value can be 0 or 1\n#     \n# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_inactivity_timeout - inactivity timeout value \n#       for the persistent cookie value \"MRHSOffice\"\n#       everytime, the SharePoint site refreshes or gets any response from\n#       SharePoint Server.  Value can be any positive value given in seconds.\n#       Default value as 60 secs\n#\n# sys_APM_MS_Office_OFBA_DG::ofba_auth_dialog_size - OFBA dialog browser\n#       resolution size given as widthxheight, default 800x600\n#\n# static::MS_OFBA_ENABLED_CLIENT_TYPE - \"ms-ofba-compliant\" session variable\n#       value that can be used in Access policy Logon agent branch, to add the required authentication\n#       for MS OFBA compliant applications.\n#\n    proc write_log {level message} {\n\n        ACCESS::log $level \"\\[MSOFBA\\] $message\"\n#       Logs printing for 12.x or older releases\n#       log -noname accesscontrol.local1.$level \"01490000: \\[MSOFBA\\] $message\"\n    }\n\n    proc is_ofba_passthrough_uri {uri} {\n        for { set i 0 } { $i < [llength $static::MS_OFBA_PASSTHROUGH_URI_LIST] } { incr i } {\n            if { $uri == [lindex $static::MS_OFBA_PASSTHROUGH_URI_LIST $i] } {\n                return 1;\n            }\n        }\n        return 0\n    }\n\n    when RULE_INIT {\n        set static::MS_OFBA_ENABLED_CLIENT_TYPE \"ms-ofba-compliant\"\n        set static::MS_OFBA_AUTH_REQ_URI \"/ms-ofba-req-auth\"\n        set static::MS_OFBA_AUTH_RETURN_URI \"/ms-ofba-auth-success\"\n        set static::MS_OFBA_AUTH_DIALOG_SZ \"800x600\"\n        set static::MS_OFBA_AUTH_SUCCESS_BODY \"<html><head><title>User Authenticated</title></head><body><b>Successful OFBA authentication</b></body></html>\"\n        set static::MS_OFBA_IRULE_DG \"sys_APM_MS_Office_OFBA_DG\"\n        set static::MULTI_DOMAIN_AUTH_RESP_URI \"/f5networks-sso-resp\"\n        set static::MS_OFBA_PASSTHROUGH_URI_LIST {$static::MULTI_DOMAIN_AUTH_RESP_URI \"/my.status.eps\" \"/my.report.eps\"}\n# sp_persistent_ck: would help to share the session from sharepoint site to\n# office applications, if enabled.\n        set static::SP_PERSISTENT_CK \"MRHSOffice\"\n        set static::SP_PERSISTENT_CK_TIMEOUT 60\n        set static::MS_OFBA_AUTH_TYPE_COOKIE \"Auth-Type\"\n        set static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE \"ms-ofba\"\n    }\n\n    when CLIENT_ACCEPTED {\n        if { ![info exists ofba_user_agent_list] } {\n# check for config change from datagroup\n# since this iRule is read-only, dg config change is done in CLIENT_ACCEPTED rather than in RULE_INIT\n            set ofba_user_agent_list [class search -value -all $static::MS_OFBA_IRULE_DG starts_with useragent]\n            set f_sp_persistent_ck [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_enabled]\n            set sp_persistent_ck_timeout [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_inactivity_timeout]\n            set ofba_auth_dialog_sz [class search -value $static::MS_OFBA_IRULE_DG equals ofba_auth_dialog_size]\n        }\n    }\n\n    when HTTP_REQUEST {\n# client detection, for ofba client\n        set ms_sp_client_type \"none\"\n        set http_path [string tolower [HTTP::path]]\n        set http_user_agent [string tolower [HTTP::header \"User-Agent\"]]\n        set session_id [HTTP::cookie value \"MRHSession\"]\n        set f_allow_session 0\n        set ms_ofba_auth_cookie \"\"\n\n        if {[HTTP::header exists \"X-FORMS_BASED_AUTH_ACCEPTED\"] &&\n            (([HTTP::header \"X-FORMS_BASED_AUTH_ACCEPTED\"] equals \"t\") ||\n             ([HTTP::header \"X-FORMS_BASED_AUTH_ACCEPTED\"] equals \"f\"))} {\n                set ms_sp_client_type \"ms-ofba\"\n            } elseif { $http_path == $static::MS_OFBA_AUTH_REQ_URI } {\n                set ms_sp_client_type \"ms-ofba\"\n            } else {\n                if {(!($http_user_agent contains \"frontpage\") && [string match -nocase {*mozilla*} $http_user_agent]) ||\n                    [string match -nocase {*opera*} $http_user_agent]} {\n                        set ms_sp_client_type \"browser\"\n                        set ms_ofba_auth_cookie [HTTP::cookie value $static::MS_OFBA_AUTH_TYPE_COOKIE]\n                        if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {\n                            # ofba authentication is still in progress, there may be a case where initial\n                            # access denied and user is retrying the session without closing the ofba\n                            # initiated browser\n                            set ms_sp_client_type \"ms-ofba\"\n                            call write_log debug \"Detecting the client type as ms-ofba based auth type cookie\"\n                        }\n                    } else {\n                        foreach ofba_user_agent $ofba_user_agent_list {\n                            set ofba_user_agent [string trim $ofba_user_agent]\n                            if { $ofba_user_agent != \"\" && [string match -nocase *$ofba_user_agent* $http_user_agent] } {\n                                set ms_sp_client_type \"ms-ofba\"\n                                    break\n                            }\n                        }\n                    }\n            }\n\n        if { $ms_sp_client_type == \"ms-ofba\" } {\n            call write_log debug \"Client-type: (ms-ofba-compliant), http path: ($http_path), user agent: ($http_user_agent)\"\n        }\n\n        if { $ms_sp_client_type != \"ms-ofba\" } {\n            return\n        } elseif { $session_id != \"\" } {\n            if { [ACCESS::session exists -state_allow $session_id] } {\n                set f_allow_session 1\n                return\n            }\n        } elseif { $f_sp_persistent_ck == \"1\" && [HTTP::cookie exists $static::SP_PERSISTENT_CK] } {\n            set sp_persistent_ck_value [HTTP::cookie value $static::SP_PERSISTENT_CK]\n            if { $sp_persistent_ck_value != \"\" && [ACCESS::session exists -state_allow $sp_persistent_ck_value] } {\n                if {not ([catch {HTTP::cookie insert name \"MRHSession\" value $sp_persistent_ck_value}]) } {\n                    call write_log debug \"Restored persistent cookie for sid: ($sp_persistent_ck_value)\"\n                    set f_allow_session 1\n                    return\n                } else {\n                    call write_log error \"Restoring persistent cookie failed for sid: ($sp_persistent_ck_value)\"\n                    unset sp_persistent_ck_value\n                }\n            } else {\n                unset sp_persistent_ck_value\n            }\n        }\n\n        if { !($f_allow_session) && $http_path != $static::MS_OFBA_AUTH_REQ_URI } {\n            if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {\n                if { ![call is_ofba_passthrough_uri $http_path]  } {\n                    call write_log debug \"Redirecting for MS OFBA, based on auth type\"\n                    HTTP::respond 302 -version 1.1 -noserver Location $static::MS_OFBA_AUTH_REQ_URI\n                }\n            } else {\n                call write_log debug \"Responding 403 for MS OFBA initiation\"\n                if {$ofba_auth_dialog_sz == \"\"} {\n                    set ofba_auth_dialog_sz $static::MS_OFBA_AUTH_DIALOG_SZ\n                }\n                HTTP::respond 403 -version \"1.1\" noserver \\\n                    \"X-FORMS_BASED_AUTH_REQUIRED\" \"https://[HTTP::host]$static::MS_OFBA_AUTH_REQ_URI\" \\\n                    \"X-FORMS_BASED_AUTH_RETURN_URL\" \"https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI\" \\\n                    \"X-FORMS_BASED_AUTH_DIALOG_SIZE\" $ofba_auth_dialog_sz \\\n                    \"Set-Cookie\" \"MRHSession=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure\" \\\n                    \"Set-Cookie\" \"LastMRH_Session=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure\" \\\n                    \"Set-Cookie\" \"$static::MS_OFBA_AUTH_TYPE_COOKIE=$static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE;path=/;secure;HttpOnly\" \\\n                    \"Connection\" \"Close\"\n            }\n        }\n    }\n\n    when HTTP_RESPONSE {\n        if { $f_sp_persistent_ck == \"1\" && ([info exists ms_sp_client_type] && $ms_sp_client_type == \"browser\") && $session_id != \"\"} {\n            if {$sp_persistent_ck_timeout == \"\"} {\n                set sp_persistent_ck_timeout $static::SP_PERSISTENT_CK_TIMEOUT\n            }\n            call write_log debug \"Set-Cookie for SharePoint persistent cookie: ($static::SP_PERSISTENT_CK) for sid: ($session_id), having timeout: ($sp_persistent_ck_timeout)\"\n\n            HTTP::cookie remove $static::SP_PERSISTENT_CK\n            HTTP::cookie insert name $static::SP_PERSISTENT_CK value $session_id path \"/\"\n            HTTP::cookie expires $static::SP_PERSISTENT_CK $sp_persistent_ck_timeout relative\n            HTTP::cookie secure $static::SP_PERSISTENT_CK enable\n            HTTP::cookie httponly $static::SP_PERSISTENT_CK enable\n\n        } elseif { [info exists sp_persistent_ck_value] && $sp_persistent_ck_value ne \"\" } {\n            call write_log debug \"Restoring Cookie for MRHSession from persistent cookie: ($sp_persistent_ck_value)\"\n\n            HTTP::cookie insert name MRHSession value $sp_persistent_ck_value path \"/\"\n            HTTP::cookie secure MRHSession enable\n            unset sp_persistent_ck_value\n        }\n    }\n\n    when ACCESS_SESSION_STARTED {\n        if { ![info exists ms_sp_client_type] || $ms_sp_client_type != \"ms-ofba\"} {\n            return\n        }\n        ACCESS::session data set session.client.type $static::MS_OFBA_ENABLED_CLIENT_TYPE\n    }\n\n    when ACCESS_ACL_ALLOWED {\n        switch -glob -- [string tolower [HTTP::path]] $static::MS_OFBA_AUTH_REQ_URI {\n            ACCESS::respond 302 noserver Location \"https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI\"\n        } $static::MS_OFBA_AUTH_RETURN_URI {\n            ACCESS::respond 200 content $static::MS_OFBA_AUTH_SUCCESS_BODY noserver \\\n                \"Set-Cookie\" \"$static::MS_OFBA_AUTH_TYPE_COOKIE=deleted;expires=Thu, 01 Jan 1970 00:00:00 GMT;;path=/;secure;HttpOnly\"\n        } \"*/signout.aspx\" {\n            ACCESS::respond 302 noserver Location \"/vdesk/hangup.php3\"\n                return\n        } \"/_layouts/accessdenied.aspx\" {\n            if {[string tolower [URI::query [HTTP::uri] loginasanotheruser]] equals \"true\" } {\n                ACCESS::session remove\n                ACCESS::respond 302 noserver Location \"/\"\n                return\n            }\n        } default {\n        }\n    }\ndefinition-signature iZGf55ghe/SCmAy8oGgqDG4kibmmFg8ihZSkO7sORsHNAuJQqpPx7PKcqlIYve4AAqLkb8tUEtxgzVV4uXZ73v5t7/DVszSnyeju+HypimEtP2crzjGlxCAxNe2hnOesZkA/6lCrcPah0MjRnQTef8vwfmQ0eKro0guM/TV+8HjyUVH2CLrPVRhEhTfwX/zlkpe6u9ZJTmNNuQVRcKRvlWPnv/6cWYPMlNPI30EMIYK6mapONBv7tY9Ojurr7FddOxG1hGctFh3Z8ufTSo81dUXrsFtba/8TwSbHYBWHs3rRZvmcv1OesnoWrFJ4E3ndmTNM76kXLylbzl7x4a1ZVQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_Office365_SAML_BasicAuth",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_Office365_SAML_BasicAuth",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_Office365_SAML_BasicAuth?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when RULE_INIT {\n        set static::ACCESS_LOG_ECP_PREFIX       \"014d0002:7: ECP client\"\n    }\n    when HTTP_REQUEST {\n        set http_path            [string tolower [HTTP::path]]\n        set http_hdr_auth        [HTTP::header Authorization]\n        set http_hdr_client_app  [HTTP::header X-MS-Client-Application]\n        set http_hdr_client_ip   [HTTP::header X-MS-Forwarded-Client-IP]\n        set MRHSession_cookie    [HTTP::cookie value MRHSession]\n\n        if { ($http_path == \"/saml/idp/profile/redirectorpost/sso\") &&\n             ($http_hdr_client_app != \"\") &&\n             ($http_hdr_client_app contains \"Microsoft.Exchange\") } {\n            HTTP::uri \"/saml/idp/profile/ecp/sso\"\n        } elseif { ($http_path != \"/saml/idp/profile/ecp/sso\")  } {\n            return\n        }\n        set f_saml_ecp_request 1\n        unset http_path\n\n        # If MRHSession cookie from client is present, skip further processing.\n        if { $MRHSession_cookie != \"\" } {\n            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_ECP_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n            } else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_ECP_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n            }\n            return\n        }\n\n        if { ($http_hdr_client_app != \"\") &&\n            ($http_hdr_client_app contains \"Microsoft.Exchange\") &&\n            ($http_hdr_client_ip != \"\") } {\n\t    set src_ip $http_hdr_client_ip\n\t}\n        unset http_hdr_client_app\n        unset http_hdr_client_ip\n\n        if { ! [ info exists src_ip ] } {\n            set src_ip          [IP::remote_addr]\n        }\n\n        # Only allow HTTP Basic Authentication.\n        if { ($http_hdr_auth == \"\") || ([ string match -nocase {basic *} $http_hdr_auth ] != 1 ) } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_ECP_PREFIX ECP request does not contain HTTP Basic Authorization header.\"\n            unset http_hdr_auth\n            return\n        }\n\n        set apm_username        [ string tolower [HTTP::username] ]\n        set apm_password        [HTTP::password]\n\n        binary scan [md5 \"$apm_password$src_ip\"] H* user_hash\n        set user_key {}\n        append user_key $apm_username \".\" $user_hash\n        unset user_hash\n\n        set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n        if { [ llength $apm_cookie_list ] != 0 } {\n            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n            if { $apm_cookie != \"\" } {\n                HTTP::cookie insert name MRHSession value $apm_cookie\n            }\n        }\n\n        HTTP::header insert \"clientless-mode\" 1\n        HTTP::header insert \"username\" $apm_username\n        HTTP::header insert \"password\" $apm_password\n        unset apm_username\n        unset apm_password\n        unset http_hdr_auth\n    }\n\n    when ACCESS_SESSION_STARTED {\n        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {\n            if { [ info exists user_key ] } {\n                ACCESS::session data set \"session.user.uuid\" $user_key\n            }\n            if { [ info exists  src_ip ] } {\n                ACCESS::session data set \"session.user.clientip\" $src_ip\n            }\n        }\n    }\n\n    when HTTP_RESPONSE {\n        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {\n            unset f_saml_ecp_request\n            unset apm_cookie\n        }\n    }\ndefinition-signature sh9fhU/ivCiEmLpiA6flX8sH3IBE1GgTQ7OpLxOMyU5ccTa9gKTiJz3/4XXZcBOxAmMBCWs8KMtArFBMI32y7QdXYLKDmvuwEEPw4vzVj0SkXzErcOpxouU0eUcn09fFOJ4cL175272f0giLFJZTPHYBRMjKNtm8vWvR65rTj02KCwueArpP5iQUR5yXdymvFB7YbCNxkl/dujJOyecdCBqcjf77l8NsgtOzv6mUHfSDcyVjEKUSGKMMLxb86hkCZODuyKv4oGC6Mgc6IOyDONOJKq7jol/CPF4aoVEqMV86EjxFudlFpGXZ+FoUrboBEkWJnqHoSDd5CMwMZA2TYQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_APM_activesync",
      "partition": "Common",
      "fullPath": "/Common/_sys_APM_activesync",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_APM_activesync?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when RULE_INIT {\n        set static::actsync_401_http_body   \"<html><title>Authentication Failed</title><body>Error: Authentication Failure</body></html>\"\n        set static::actsync_503_http_body   \"<html><title>Service is not available</title><body>Error: Service is not available</body></html>\"\n        set static::ACCESS_LOG_PREFIX       \"01490000:7:\"\n    }\n    when HTTP_REQUEST {\n        set http_path                       [string tolower [HTTP::path]]\n        set f_clientless_mode               0\n\n        if { $http_path == \"/microsoft-server-activesync\" } {\n        }\n        elseif { $http_path == \"/autodiscover/autodiscover.xml\" } {\n            set f_auto_discover 1\n        }\n        else return\n\n        if { ! [ info exists src_ip ] } {\n            set src_ip                            [IP::remote_addr]\n        }\n        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {\n            set PROFILE_RESTRICT_SINGLE_IP  \t  1\n        }\n        # Only allow HTTP Basic Authentication.\n        set auth_info_b64enc                \"\"\n        set http_hdr_auth                   [HTTP::header Authorization]\n        regexp -nocase {Basic (.*)} $http_hdr_auth match auth_info_b64enc\n        if { $auth_info_b64enc == \"\" } {\n            set http_hdr_auth \"\"\n        }\n\n        if { $http_hdr_auth == \"\" } {\n            log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX Empty/invalid HTTP Basic Authorization header\"\n            HTTP::respond 401 content $static::actsync_401_http_body Connection close\n            return\n        }\n\n        set MRHSession_cookie               [HTTP::cookie value MRHSession]\n        # Do we have valid MRHSession cookie.\n        if { $MRHSession_cookie != \"\" } {\n            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie\"\n                # Default profile access setting is false\n                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n                    return\n                }\n                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie \"session.user.clientip\" ] ] } {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP matched\"\n                    return\n                }\n                else {\n                    log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX source IP does not matched\"\n                }\n            }\n            else {\n                log -noname accesscontrol.local1.debug \"$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie\"\n            }\n            set MRHSession_cookie \"\"\n            HTTP::cookie remove MRHSession\n        }\n\n        set apm_username                    [ string tolower [HTTP::username] ]\n        set apm_password                    [HTTP::password]\n\n        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {\n            binary scan [md5 \"$apm_password$\"] H* user_hash\n        } else {\n            binary scan [md5 \"$apm_password$src_ip\"] H* user_hash\n        }\n        set user_key {}\n        append user_key $apm_username \".\" $user_hash\n        unset user_hash\n\n        set f_insert_clientless_mode    0\n        set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n        if { [ llength $apm_cookie_list ] != 0 } {\n            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n            if { $apm_cookie != \"\" } {\n                HTTP::cookie insert name MRHSession value $apm_cookie\n            } else {\n                set f_insert_clientless_mode 1\n            }\n        } else {\n            set f_insert_clientless_mode 1\n        }\n\n        if { $f_insert_clientless_mode == 1 } {\n            HTTP::header insert \"clientless-mode\" 1\n            HTTP::header insert \"username\" $apm_username\n            HTTP::header insert \"password\" $apm_password\n        }\n        unset f_insert_clientless_mode\n    }\n    when ACCESS_SESSION_STARTED {\n        if { [ info exists user_key ] } {\n            ACCESS::session data set \"session.user.uuid\" $user_key\n            ACCESS::session data set \"session.user.microsoft-exchange-client\" 1\n            ACCESS::session data set \"session.user.activesync\" 1\n            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {\n                set f_auto_discover 0\n                ACCESS::session data set \"session.user.microsoft-autodiscover\" 1\n            }\n        }\n    }\n    when ACCESS_POLICY_COMPLETED {\n        if { ! [ info exists user_key ] } {\n            return\n        }\n\n        set policy_result [ACCESS::policy result]\n        switch $policy_result {\n        \"allow\" {\n        }\n        \"deny\" {\n            ACCESS::respond 401 content $static::actsync_401_http_body Connection close\n            ACCESS::session remove\n        }\n        default {\n            ACCESS::respond 503 content $static::actsync_503_http_body Connection close\n            ACCESS::session remove\n        }\n        }\n\n        unset user_key\n    }\ndefinition-signature spIagrH9Xn9IG7rs4q4r0/ANUUJrvYo0d1Gh+2LLA20m7qM6EdVUofs5/pnJYV9OG9t9qkM3531vwT+IdBOX/N2aOPfMnhE4o5qKlMjecBSdLSUikVrWNjxM9kxJgPFTD3CjO2xPbkfghm067JvFCiJh4wcT+zeT2iru/ri8NSRrS+vOYlR4oAFO60N+bXNGB6Z4lLcYYg+lD2+wiZz2I57XuMXmRWANOcK1/HEoM2XPATB8kFZqtZJT5YDodibKmt677sD+HjtzsmgjtxeSNE41urVdZHLvHh9f8KOZjF+Qhl9AZrUgTKaDp8K6QH3BC5nLU/ByrPHD/2tI8z7abA==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_krbdelegate",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_krbdelegate",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_krbdelegate?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when HTTP_REQUEST {\n        set thecert \"\"\n        set ckname F5KRBAUTH\n        set ckpass abc123\n        set authprofiles [PROFILE::list auth]\n        # Search the auth profiles for the krbdelegate(7) and grab cookie info\n        foreach profname $authprofiles {\n            if { [PROFILE::auth $profname type] == 7 } {\n                set tmpckname [PROFILE::auth $profname cookie_name]\n                set tmpckpass [PROFILE::auth $profname cookie_key]\n                if {[PROFILE::auth $profname cookie_name] != \"\" } {\n                    set ckname $tmpckname\n                    set ckpass $tmpckpass\n                    break\n                }\n            }\n        }\n        set seecookie 0\n        set insertcookie 0\n        # check for the cookie\n        if {not [info exists tmm_auth_http_sids(krbdelegate)]} {\n            set tmm_auth_sid [AUTH::start pam default_krbdelegate]\n            set tmm_auth_http_sids(krbdelegate) $tmm_auth_sid\n            AUTH::subscribe $tmm_auth_sid\n        } else {\n            set tmm_auth_sid $tmm_auth_http_sids(krbdelegate)\n        }\n        if { [PROFILE::exists clientssl] } {\n            set certcmd \"SSL::cert 0\"\n            set thecert [ eval $certcmd ]\n        }\n        if { $thecert == \"\" } {\n            # if no cert, assume old kerb delegation\n            # if there is no Authorization header and no cookie, get one.\n            if { ([HTTP::header Authorization] == \"\") and\n                  (not [HTTP::cookie exists $ckname])} {\n                HTTP::respond 401 WWW-Authenticate Negotiate\n                return\n            }\n        }\n        if {[HTTP::cookie exists $ckname]} {\n            set ckval [HTTP::cookie decrypt $ckname $ckpass]\n            AUTH::username_credential $tmm_auth_sid \"cookie\"\n            AUTH::password_credential $tmm_auth_sid $ckval\n            set seecookie 1\n        } else {\n            if { $thecert == \"\" } {\n                # Kerberos Delegation - set username\n                # Strip off the Negotiate before the base64d goodness\n                AUTH::username_credential $tmm_auth_sid [lindex [HTTP::header Authorization] 1]\n            }\n            else {\n                # Protocol Transition - set ttm_auth_sid\n                AUTH::username_credential $tmm_auth_sid \"krpprottran\"\n                AUTH::cert_credential $tmm_auth_sid $thecert\n            }\n            AUTH::password_credential $tmm_auth_sid \"xxxx\"\n        }\n        AUTH::authenticate $tmm_auth_sid\n\n        if {not [info exists tmm_auth_http_collect_count]} {\n            HTTP::collect\n            set tmm_auth_http_successes 0\n            set tmm_auth_http_collect_count 1\n        } else {\n            incr tmm_auth_http_collect_count\n        }\n    }\n    when AUTH_RESULT {\n        if {not [info exists tmm_auth_http_sids(krbdelegate)] or \\\n            ($tmm_auth_http_sids(krbdelegate) != [AUTH::last_event_session_id]) or \\\n            (not [info exists tmm_auth_http_collect_count])} {\n            return\n        }\n        if {[AUTH::status] == 0} {\n            incr tmm_auth_http_successes\n        }\n        # If multiple auth sessions are pending and\n        # one failure results in termination and this is a failure\n        # or enough successes have now occurred\n        if {([array size tmm_auth_http_sids] > 1) and \\\n            ((not [info exists tmm_auth_http_sufficient_successes] or \\\n             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {\n            # Abort the other auth sessions\n            foreach {type sid} [array get tmm_auth_http_sids] {\n                unset tmm_auth_http_sids($type)\n                if {($type ne \"krbdelegate\") and ($sid != -1)} {\n                    AUTH::abort $sid\n                    incr tmm_auth_http_collect_count -1\n               }\n            }\n        }\n        # If this is the last outstanding auth then either\n        # release or respond to this session\n        incr tmm_auth_http_collect_count -1\n        if {$tmm_auth_http_collect_count == 0} {\n            unset tmm_auth_http_collect_count\n            if { [AUTH::status] == 0 } {\n                array set pamout [AUTH::response_data]\n                HTTP::header replace Authorization \"Negotiate $pamout(krbdelegate:attr:SPNEGO)\"\n                if {$seecookie == 0} {\n                    set insertcookie $pamout(krbdelegate:attr:KRB5CCNAME)\n                }\n                HTTP::release\n            } else {\n                HTTP::respond 401 WWW-Authenticate Negotiate \"Set-Cookie\" \"$ckname= ; expires=Wed Dec 31 16:00:00 1969\"\n            }\n        }\n    }\n    # When the response goes out, if we need to insert a cookie, do it.\n    when HTTP_RESPONSE {\n        if {$insertcookie != 0} {\n            HTTP::cookie insert name $ckname value $insertcookie\n            HTTP::cookie encrypt $ckname $ckpass\n        }\n    }\ndefinition-signature ax5Zk9GEaYsygCFJ/c4SVC/p2nhi9tPNyXKogSH/i+o42+wUmNzts0fiOT0u3zK2PqPEpYtBRzpc84CF6cz8fHYjOrjVuKt/ccWhVIqvSey4sGWV5pYlOWbETi2tFImnxPUn6q9esTmlfXMjuflsx3mJXzw35zEvBhaGMmZ853RVmANRpqP+NJUwFJjrb6rJ+ptlfKMTZPt32/ZRoSXubiWHDZ36eH7bpyisXp/jZiVt/kvhEYDITuFT9BzlTRC+1oiUKvEfxfBvl7f+1d+uORDdPnv2UeUrFWspmVw1THCPCyRfPQvbZaL+FmYh5I9XO0ODhBznKrtdwrLeBuDIuQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_ldap",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_ldap",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_ldap?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when HTTP_REQUEST {\n        if {not [info exists tmm_auth_http_sids(ldap)]} {\n            set tmm_auth_sid [AUTH::start pam default_ldap]\n            set tmm_auth_http_sids(ldap) $tmm_auth_sid\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_sid\n            }\n        } else {\n            set tmm_auth_sid $tmm_auth_http_sids(ldap)\n        }\n        AUTH::username_credential $tmm_auth_sid [HTTP::username]\n        AUTH::password_credential $tmm_auth_sid [HTTP::password]\n        AUTH::authenticate $tmm_auth_sid\n\n        if {not [info exists tmm_auth_http_collect_count]} {\n            HTTP::collect\n            set tmm_auth_http_successes 0\n            set tmm_auth_http_collect_count 1\n        } else {\n            incr tmm_auth_http_collect_count\n        }\n    }\n    when AUTH_RESULT {\n        if {not [info exists tmm_auth_http_sids(ldap)] or \\\n           ($tmm_auth_http_sids(ldap) != [AUTH::last_event_session_id]) or \\\n           (not [info exists tmm_auth_http_collect_count])} {\n            return\n        }\n        if {[AUTH::status] == 0} {\n            incr tmm_auth_http_successes\n        }\n        # If multiple auth sessions are pending and\n        # one failure results in termination and this is a failure\n        # or enough successes have now occurred\n        if {([array size tmm_auth_http_sids] > 1) and \\\n            ((not [info exists tmm_auth_http_sufficient_successes] or \\\n             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {\n            # Abort the other auth sessions\n            foreach {type sid} [array get tmm_auth_http_sids] {\n                unset tmm_auth_http_sids($type)\n                if {($type ne \"ldap\") and ($sid != -1)} {\n                    AUTH::abort $sid\n                    incr tmm_auth_http_collect_count -1\n                }\n            }\n        }\n\n        # If this is the last outstanding auth then either\n        # release or respond to this session\n        incr tmm_auth_http_collect_count -1\n        if {$tmm_auth_http_collect_count == 0} {\n            unset tmm_auth_http_collect_count\n            if {[AUTH::status] == 0} {\n                HTTP::release\n            } else {\n                HTTP::respond 401\n            }\n        }\n    }\ndefinition-signature ivtbsTt8rheTfPgwLBGpP81b8OdTgGGm1ZBOfZfAvzuT9By32DafRf/n0g7oLZl9yGrqmwcuHmcRsRgAbrvZBlDebWJSRjd2DQoYg2T2+jli0qGy6eNJC8Aw3Du/ldfRxk9vgNKisz5m7SrObMJhp59YVORC6gZMGcvwzRAeI5a1MtNoWFjMIeYULeRQMs+ut/0QKpaCDhQXGyM9Nf9iSaP5V9FdlaT+1X4zCeu0kCAKdxD+5fy2QhR/1B6Yne4lqHLkbIhN22MN9dfPryFGxtW+HryW+hLydl3jLJgfdRltlII9RC/7sNBrrw+1G+pimKbExFUhKlgv3S+AfPyYZA==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_radius",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_radius",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_radius?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when HTTP_REQUEST {\n        if {not [info exists tmm_auth_http_sids(radius)]} {\n            set tmm_auth_sid [AUTH::start pam default_radius]\n            set tmm_auth_http_sids(radius) $tmm_auth_sid\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_sid\n            }\n        } else {\n            set tmm_auth_sid $tmm_auth_http_sids(radius)\n        }\n        AUTH::username_credential $tmm_auth_sid [HTTP::username]\n        AUTH::password_credential $tmm_auth_sid [HTTP::password]\n        AUTH::authenticate $tmm_auth_sid\n\n        if {not [info exists tmm_auth_http_collect_count]} {\n            HTTP::collect\n            set tmm_auth_http_successes 0\n            set tmm_auth_http_collect_count 1\n        } else {\n            incr tmm_auth_http_collect_count\n        }\n    }\n    when AUTH_RESULT {\n        if {not [info exists tmm_auth_http_sids(radius)] or \\\n            ($tmm_auth_http_sids(radius) != [AUTH::last_event_session_id]) or \\\n            (not [info exists tmm_auth_http_collect_count])} {\n            return\n        }\n        if {[AUTH::status] == 0} {\n            incr tmm_auth_http_successes\n        }\n        # If multiple auth sessions are pending and\n        # one failure results in termination and this is a failure\n        # or enough successes have now occurred\n        if {([array size tmm_auth_http_sids] > 1) and \\\n            ((not [info exists tmm_auth_http_sufficient_successes] or \\\n             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {\n            # Abort the other auth sessions\n            foreach {type sid} [array get tmm_auth_http_sids] {\n                unset tmm_auth_http_sids($type)\n                if {($type ne \"radius\") and ($sid != -1)} {\n                    AUTH::abort $sid\n                    incr tmm_auth_http_collect_count -1\n                }\n            }\n        }\n        # If this is the last outstanding auth then either\n        # release or respond to this session\n        incr tmm_auth_http_collect_count -1\n        if {$tmm_auth_http_collect_count == 0} {\n            unset tmm_auth_http_collect_count\n            if { [AUTH::status] == 0 } {\n                HTTP::release\n            } else {\n                HTTP::respond 401\n            }\n        }\n    }\ndefinition-signature IKEOxzIt+/olVVs5ljd6RYYXcLSSPbTHc/N2BSC5FFeNI8xe4T3VpkirN4jkyQOnnySD6JSeDWEekzuatxv2Zj6u0pDBkTk7glhkWQ1qn9qqgSlySyX3vs1t/YA2QvzgW2mnOAwhNebTrGdAz+Rvl0uJlOtH6hiwkqj6AGTU9FtoMfGkxbkjRptdxVcScOs7xtcwN85W+kuP1giU+yslMpF/b5PGJLDua0cnp2UWMVkRF+bJ1WlTluBcd27YIPhZtBkYUZknRYiyZ1mo3+eUI11blhz7mI8XiiAPcL1sVpirCF1PROkD5MrtVKqMdjG2d/CCc5XMVCUF8Wu2CEkThg==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_ssl_cc_ldap",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_ssl_cc_ldap",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_ssl_cc_ldap?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when CLIENT_ACCEPTED {\n        set tmm_auth_ssl_cc_ldap_sid 0\n        set tmm_auth_ssl_cc_ldap_done 0\n    }\n    when CLIENTSSL_CLIENTCERT {\n        if {[SSL::cert count] == 0} {\n            return\n        }\n        set tmm_auth_ssl_cc_ldap_done 0\n        if {$tmm_auth_ssl_cc_ldap_sid == 0} {\n            set tmm_auth_ssl_cc_ldap_sid [AUTH::start pam default_ssl_cc_ldap]\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_ssl_cc_ldap_sid\n            }\n        }\n        AUTH::cert_credential $tmm_auth_ssl_cc_ldap_sid [SSL::cert 0]\n        AUTH::authenticate $tmm_auth_ssl_cc_ldap_sid\n        SSL::handshake hold\n    }\n    when CLIENTSSL_HANDSHAKE {\n        set tmm_auth_ssl_cc_ldap_done 1\n    }\n    when AUTH_RESULT {\n        if {[info exists tmm_auth_ssl_cc_ldap_sid] and \\\n            ($tmm_auth_ssl_cc_ldap_sid == [AUTH::last_event_session_id])} {\n            set tmm_auth_status [AUTH::status]\n            if {$tmm_auth_status == 0} {\n                set tmm_auth_ssl_cc_ldap_done 1\n                SSL::handshake resume\n            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_cc_ldap_done == 0} {\n                reject\n            }\n        }\n    }\ndefinition-signature LtRGyLVLmGrOazlR7X/5LJB/TttBDo9XlFr5ATtyQ0jObANtTQ+TFigApDvtqpXZ3vOx9tTbCQ8SUnr9e1AT9Itvat+lanwUcJsYknKCT8/5qVLojcL7gkdONMk4H5gjhsRf6RlfJO2oPSEyYY8MgP4b5m/jj3PuSPzS8H5V0PXYOuxMyJD2dQyhxRNR6huMNYyHE+xX6Gp7QT5Wj2RnDTT84QiPJAOoA8AGQdS2DZYzItkQcynEUD3aNI8zufBoMfRmN+nbiK6CVg8odr49wLCwGOZYQ9EzqJLAcjkQx51ot4KhzaY1Iz2DMZaM52fp/J55U2fYBlLLgWszfY+phg==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_ssl_crldp",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_ssl_crldp",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_ssl_crldp?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when CLIENT_ACCEPTED {\n        set tmm_auth_ssl_crldp_sid 0\n        set tmm_auth_ssl_crldp_done 0\n    }\n    when CLIENTSSL_CLIENTCERT {\n        if {[SSL::cert count] == 0} {\n            return\n        }\n        set tmm_auth_ssl_crldp_done 0\n        if {$tmm_auth_ssl_crldp_sid == 0} {\n            set tmm_auth_ssl_crldp_sid [AUTH::start pam default_ssl_crldp]\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_ssl_crldp_sid\n            }\n        }\n        AUTH::cert_credential $tmm_auth_ssl_crldp_sid [SSL::cert 0]\n        AUTH::cert_issuer_credential $tmm_auth_ssl_crldp_sid [SSL::cert issuer 0]\n        AUTH::authenticate $tmm_auth_ssl_crldp_sid\n        SSL::handshake hold\n    }\n    when CLIENTSSL_HANDSHAKE {\n        set tmm_auth_ssl_crldp_done 1\n    }\n    when AUTH_RESULT {\n        if {[info exists tmm_auth_ssl_crldp_sid] and \\\n            ($tmm_auth_ssl_crldp_sid == [AUTH::last_event_session_id])} {\n            set tmm_auth_status [AUTH::status]\n            if {$tmm_auth_status == 0} {\n                set tmm_auth_ssl_crldp_done 1\n                SSL::handshake resume\n            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_crldp_done == 0} {\n                reject\n            }\n        }\n    }\ndefinition-signature BH/sgHzgcQin7sshuTFXGbdDJFWrfeTKnk1QJMLaKsvs9ip21N5FBbMkKXsR9EeIEMlHJOnfc6sWBDFEA7OqfgqBfVPfOBJdJI9SO+eES7DGpHgkI3Bx3nRJLx/BIkCE2zrw/nWON/bx5SRVxySkw5A498OWMygc4jpZzpi3EqskO4E0zb3LXlcG67D994JJ79aVuwrADm4YIErt+nfITSUWMa6/loBIAS5/kAx0Qn77SaHs9xIyVD4gQ5cjL8xtztWSCi5h3sRf8tB24UZlSLX2zMp+XqpiZ1gAUDFHxA+VZxO68w47OEt+7tkB9XYHxe4c2ICUr0lOx3CL2TcILQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_ssl_ocsp",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_ssl_ocsp",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_ssl_ocsp?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when CLIENT_ACCEPTED {\n        set tmm_auth_ssl_ocsp_sid 0\n        set tmm_auth_ssl_ocsp_done 0\n    }\n    when CLIENTSSL_CLIENTCERT {\n        if {[SSL::cert count] == 0} {\n            return\n        }\n        set tmm_auth_ssl_ocsp_done 0\n        if {$tmm_auth_ssl_ocsp_sid == 0} {\n            set tmm_auth_ssl_ocsp_sid [AUTH::start pam default_ssl_ocsp]\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_ssl_ocsp_sid\n            }\n        }\n        AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]\n        AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]\n        AUTH::authenticate $tmm_auth_ssl_ocsp_sid\n        SSL::handshake hold\n    }\n    when CLIENTSSL_HANDSHAKE {\n        set tmm_auth_ssl_ocsp_done 1\n    }\n    when AUTH_RESULT {\n        if {[info exists tmm_auth_ssl_ocsp_sid] and \\\n            ($tmm_auth_ssl_ocsp_sid == [AUTH::last_event_session_id])} {\n            set tmm_auth_status [AUTH::status]\n            if {$tmm_auth_status == 0} {\n                set tmm_auth_ssl_ocsp_done 1\n                SSL::handshake resume\n            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_ocsp_done == 0} {\n                reject\n            }\n        }\n    }\ndefinition-signature ktNVlhAOxT+OGPkApI2/aMmPzh8Hb8UXsNkfzZgT3aBCOxKLvZOnZGRqCorvA07rBoDgX3RUYKj8zR4mSpVriE9kyfGGQjn0kfoEKH5ZMUzgLqI6Qi6KZnGsBAO45plxjcnJPRlRWRfWGGxqfj46ULbiKCjeRtCqjfyj+ctUTmiFEuFl9dDGlCgem10mm/fqTzfo7Q6IEk8k8G36iWLeI3w0/F/5bqfhilA9YnMMae1EF9roWUm80FUnOEKagHAeQhlyv+RJra10mTFSG433Oj7kFNT13HPmaOC/KI9juqEGKlBftSO+2Jq7qtKuCUxQQDoJjABoKlR51T8S7phRtw==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_auth_tacacs",
      "partition": "Common",
      "fullPath": "/Common/_sys_auth_tacacs",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_auth_tacacs?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when HTTP_REQUEST {\n        if {not [info exists tmm_auth_http_sids(tacacs)]} {\n            set tmm_auth_sid [AUTH::start pam default_tacacs]\n            set tmm_auth_http_sids(tacacs) $tmm_auth_sid\n            if {[info exists tmm_auth_subscription]} {\n                AUTH::subscribe $tmm_auth_sid\n            }\n        } else {\n            set tmm_auth_sid $tmm_auth_http_sids(tacacs)\n        }\n        AUTH::username_credential $tmm_auth_sid [HTTP::username]\n        AUTH::password_credential $tmm_auth_sid [HTTP::password]\n        AUTH::authenticate $tmm_auth_sid\n\n        if {not [info exists tmm_auth_http_collect_count]} {\n            HTTP::collect\n            set tmm_auth_http_successes 0\n            set tmm_auth_http_collect_count 1\n        } else {\n            incr tmm_auth_http_collect_count\n        }\n    }\n    when AUTH_RESULT {\n        if {not [info exists tmm_auth_http_sids(tacacs)] or \\\n            ($tmm_auth_http_sids(tacacs) != [AUTH::last_event_session_id]) or \\\n            (not [info exists tmm_auth_http_collect_count])} {\n            return\n        }\n        if {[AUTH::status] == 0} {\n            incr tmm_auth_http_successes\n        }\n        # If multiple auth sessions are pending and\n        # one failure results in termination and this is a failure\n        # or enough successes have now occurred\n        if {([array size tmm_auth_http_sids] > 1) and \\\n            ((not [info exists tmm_auth_http_sufficient_successes] or \\\n             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {\n            # Abort the other auth sessions\n            foreach {type sid} [array get tmm_auth_http_sids] {\n                unset tmm_auth_http_sids($type)\n                if {($type ne \"tacacs\") and ($sid != -1)} {\n                    AUTH::abort $sid\n                    incr tmm_auth_http_collect_count -1\n                }\n            }\n        }\n        # If this is the last outstanding auth then either\n        # release or respond to this session\n        incr tmm_auth_http_collect_count -1\n        if {$tmm_auth_http_collect_count == 0} {\n            unset tmm_auth_http_collect_count\n            if { [AUTH::status] == 0 } {\n                HTTP::release\n            } else {\n                HTTP::respond 401\n            }\n        }\n    }\ndefinition-signature Uq7dIMC0Aws84ull+0BeivuhFi+Va6Sy0gb5wEE2cygYJ8hh9mszXphWSNH8DuMv9TrpORcWJtf+iFYq2M9SmqA9Ld8vWd3Fp3WprEYPqTz92+78kjUbB3arZ4v7o94gHY4YD6DmKl99uYrIWTobWvLyq+VCk6CE7brpz3BJRgAO1+ISN01G0qWBMoDgSy02xkc1yEc2DroFjQd/K54S2jMPrQf1RrJx2iQysNoC7go0qQy+DseLeNovqUE/KOnb6Gzhma77om0kUWte/luEQ4Lb13+7vZjLlemoMPlSFdwYWHWELi775OiulQEcfbY0BQCIkCYH+2JRe2iiBVmAOQ==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    },
    {
      "kind": "tm:ltm:rule:rulestate",
      "name": "_sys_https_redirect",
      "partition": "Common",
      "fullPath": "/Common/_sys_https_redirect",
      "generation": 1,
      "selfLink": "https://localhost/mgmt/tm/ltm/rule/~Common~_sys_https_redirect?ver=16.1.3",
      "apiAnonymous": "nodelete nowrite \n# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement (\"EULA\")\n# for license terms. Notwithstanding anything to the contrary in the EULA,\n# Licensee may copy and modify this software product for its internal business\n# purposes. Further, Licensee may upload, publish and distribute the modified\n# version of the software product on devcentral.f5.com.\n#\n    when HTTP_REQUEST {\n       HTTP::redirect https://[getfield [HTTP::host] \":\" 1][HTTP::uri]\n    }\ndefinition-signature tJY87UPbfpgQ3TPXqXhbCAgqIJhR1MvyFxXLTX/wNqmH+XV51tNkr8HWmv4PBq8hm6w7peLKj88shG+0RiX+yAMU31n6jS9vRcg0VKNPBWLTzu3Ic8abqyyY6XYgkMel+d9Sa8x+vakcuPcAZ0dnICHQiQFePjxYUD0XKwIrbGqQb8vEcU3HHbDaLoMQry4KDnV3s1crFpWXBZBo6esIdzM/s0jYncqZBNdTmIEH3ujEunmo2Jh9MBDhwfGKy1XwCfeeZvzk8b1J+HbRk7W/vbrRUewJZDt+Z13i9u/MbneAL4QXZgtjSxU2nN4GcZjWePUIm7oxc1nz9FGeNva1xg==",
      "apiRawValues": {
        "verificationStatus": "signature-verified"
      }
    }
  ]
}